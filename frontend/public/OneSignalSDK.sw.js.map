{"version":3,"file":"OneSignalSDK.sw.js","sources":["../../src/core/operationRepo/constants.ts","../../src/shared/subscriptions/constants.ts","../../src/shared/useragent/constants.ts","../../src/shared/useragent/detect.ts","../../src/shared/utils/EnvVariables.ts","../../src/shared/environment/detect.ts","../../src/shared/models/DeliveryPlatformKind.ts","../../src/shared/errors/common.ts","../../src/shared/helpers/general.ts","../../src/shared/helpers/validators.ts","../../src/shared/libraries/Log.ts","../../src/shared/api/base.ts","../../src/core/constants.ts","../../src/shared/utils/Encoding.ts","../../src/core/requests/api.ts","../../src/shared/context/helpers.ts","../../src/shared/api/sw.ts","../../src/shared/context/constants.ts","../../src/shared/prompts/constants.ts","../../src/shared/config/constants.ts","../../src/shared/config/prompt.ts","../../src/shared/config/integration.ts","../../src/shared/config/app.ts","../../src/shared/config/version.ts","../../src/shared/config/domain.ts","../../node_modules/idb/build/index.js","../../src/shared/session/constants.ts","../../src/shared/database/client.ts","../../src/shared/database/constants.ts","../../src/shared/database/upgrade.ts","../../src/shared/database/notifications.ts","../../src/shared/helpers/serializer.ts","../../src/shared/models/Subscription.ts","../../src/shared/database/subscription.ts","../../src/sw/helpers/CancelableTimeout.ts","../../src/shared/session/helpers.ts","../../src/shared/helpers/service-worker.ts","../../src/shared/helpers/OutcomesHelper.ts","../../src/shared/models/Outcomes.ts","../../src/shared/api/shared.ts","../../src/shared/libraries/workerMessenger/constants.ts","../../src/shared/libraries/workerMessenger/base.ts","../../src/shared/libraries/workerMessenger/sw.ts","../../src/shared/models/RawPushSubscription.ts","../../src/shared/managers/subscription/base.ts","../../src/shared/managers/subscription/constants.ts","../../src/shared/models/SubscriptionStrategyKind.ts","../../src/shared/managers/subscription/sw.ts","../../src/shared/models/ContextSW.ts","../../src/shared/helpers/context.ts","../../src/sw/helpers/notifications.ts","../../src/sw/webhooks/OSWebhookSender.ts","../../src/sw/webhooks/notifications/OSWebhookNotificationEventSender.ts","../../src/sw/serviceWorker/ServiceWorker.ts","../../src/sw/serviceWorker/helpers.ts","../../src/shared/database/config.ts","../../src/entries/worker.ts"],"sourcesContent":["// Reference: OneSignalSDK/onesignal/core/src/main/java/com/onesignal/core/internal/config/ConfigModel.kt\nexport const OP_REPO_DEFAULT_FAIL_RETRY_BACKOFF = 1000;\nexport const OP_REPO_POST_CREATE_DELAY = 500;\nexport const OP_REPO_EXECUTION_INTERVAL = 500;\nexport const OP_REPO_POST_CREATE_RETRY_UP_TO = 15_000;\nexport const RETRY_MS = 10_000;\n","export const SubscriptionChannel = {\n  Email: 'Email',\n  SMS: 'SMS',\n  Push: 'Push',\n} as const;\n\nexport const SubscriptionType = {\n  ChromePush: 'ChromePush',\n  Email: 'Email',\n  SMS: 'SMS',\n  SafariPush: 'SafariPush',\n  SafariLegacyPush: 'SafariLegacyPush',\n  FirefoxPush: 'FirefoxPush',\n  // And others but not relevant for Web SDK\n  // macOSPush: 'macOSPush',\n  // AndroidPush: 'AndroidPush',\n  // FireOSPush: 'FireOSPush',\n  // HuaweiPush: 'HuaweiPush',\n  // iOSPush: 'iOSPush',\n  // WindowsPush: 'WindowsPush',\n} as const;\n\nexport const NotificationType = {\n  // Notification permission is not granted at the browser level.\n  // Used if the native notification permission is 'default' or 'declined'\n  NoNativePermission: 0,\n  // Everything is available for the subscription to be enabled;\n  // not opted out, has token, and notification permission is granted.\n  Subscribed: 1,\n  // OneSignal.User.PushSubscription.optOut() called or end-user opted out from SDK bell widget\n  // UserOptedOut takes priority over NoNativePermission\n  UserOptedOut: -2,\n  NotSubscribed: -10,\n  TemporaryWebRecord: -20,\n  PermissionRevoked: -21,\n  PushSubscriptionRevoked: -22,\n  ServiceWorkerStatus403: -23,\n  ServiceWorkerStatus404: -24,\n} as const;\n","export const Browser = {\n  Chrome: 'chrome',\n  Edge: 'edge',\n  Safari: 'safari',\n  Firefox: 'firefox',\n  Other: 'other',\n} as const;\n","import { Browser } from './constants';\nimport type { BrowserValue } from './types';\n\ninterface BrowserConfig {\n  _name: string;\n  _pattern: RegExp;\n  _versionPattern: RegExp;\n}\n\ninterface IBrowserResult {\n  name: string;\n  version: string;\n}\n\n// Top popular browsers set\nconst BROWSER_CONFIGS: BrowserConfig[] = [\n  {\n    _name: 'Opera',\n    _pattern: /(?:opera|opr|opios)/i,\n    _versionPattern: /(?:opera|opr|opios)[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Facebook',\n    _pattern: /FBAN\\//i,\n    _versionPattern: /FBAV\\/(\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Samsung Browser',\n    _pattern: /samsungbrowser/i,\n    _versionPattern: /samsungbrowser[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Yandex Browser',\n    _pattern: /yabrowser/i,\n    _versionPattern: /yabrowser[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Vivaldi',\n    _pattern: /vivaldi/i,\n    _versionPattern: /vivaldi[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'UC Browser',\n    _pattern: /ucbrowser/i,\n    _versionPattern: /ucbrowser[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Microsoft Edge',\n    _pattern: /edg/i,\n    _versionPattern: /edg[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Firefox',\n    _pattern: /firefox|iceweasel|fxios/i,\n    _versionPattern: /(?:firefox|iceweasel|fxios)[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Chromium',\n    _pattern: /chromium/i,\n    _versionPattern: /chromium[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Chrome',\n    _pattern: /chrome|crios|crmo/i,\n    _versionPattern: /(?:chrome|crios|crmo)[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n  {\n    _name: 'Safari',\n    _pattern: /safari|applewebkit/i,\n    _versionPattern: /version[ /](\\d+(?:\\.\\d+)?)/i,\n  },\n];\n\nexport function getBrowser(userAgent: string): IBrowserResult {\n  for (const config of BROWSER_CONFIGS) {\n    if (config._pattern.test(userAgent)) {\n      const version = userAgent.match(config._versionPattern)?.[1] ?? '';\n      return { name: config._name, version };\n    }\n  }\n  return { name: 'Unknown', version: '' };\n}\nconst isAndroid = (userAgent: string): boolean =>\n  !/like android/i.test(userAgent) && /android/i.test(userAgent);\n\nconst getIOSDeviceType = (userAgent: string): string =>\n  userAgent.match(/(iphone|ipod|ipad)/i)?.[1]?.toLowerCase() || '';\n\n// Based off detect-ua logic: https://github.com/TimvanScherpenzeel/detect-ua\nexport function isTabletBrowser(userAgent = navigator.userAgent): boolean {\n  const ios = getIOSDeviceType(userAgent);\n\n  return (\n    (/tablet/i.test(userAgent) && !/tablet pc/i.test(userAgent)) ||\n    ios === 'ipad' ||\n    (isAndroid(userAgent) && !/[^-]mobi/i.test(userAgent)) ||\n    (!/nexus\\s*[0-6]\\s*/i.test(userAgent) && /nexus\\s*\\d+/i.test(userAgent))\n  );\n}\n\n// Based off detect-ua logic: https://github.com/TimvanScherpenzeel/detect-ua\nexport function isMobileBrowser(userAgent = navigator.userAgent): boolean {\n  if (isTabletBrowser(userAgent)) return false;\n\n  const ios = getIOSDeviceType(userAgent);\n  return (\n    /[^-]mobi/i.test(userAgent) ||\n    ios === 'iphone' ||\n    ios === 'ipod' ||\n    isAndroid(userAgent)\n  );\n}\n\nconst BROWSER_MAP: Record<string, BrowserValue> = {\n  Chrome: Browser.Chrome,\n  Chromium: Browser.Chrome,\n  Firefox: Browser.Firefox,\n  'Microsoft Edge': Browser.Edge,\n  Safari: Browser.Safari,\n};\n\nexport function getBrowserName(): BrowserValue {\n  return BROWSER_MAP[getBrowser(navigator.userAgent).name] || Browser.Other;\n}\n\nexport const getBrowserVersion = (): number => {\n  const version = getBrowser(navigator.userAgent).version;\n  if (!version) return -1;\n  const [major, minor = '0'] = version.split('.');\n  return +`${major}.${minor}`;\n};\n\nexport function requiresUserInteraction(): boolean {\n  const browserName = getBrowserName();\n  const version = getBrowserVersion();\n  return (\n    (browserName === Browser.Firefox && version >= 72) ||\n    (browserName === Browser.Safari && version >= 12.1)\n  );\n}\n","// NOTE: We are using a function to get the value of the environment variable to make it easier to test.\n// We also are using typeof check since defining global constants (through Vite) DOES NOT work for the service worker.\n// ^ This only applies to development mode since we have separate bundles (entries) for the service worker and the main bundle.\n\n// strings\nexport const API_TYPE =\n  typeof __API_TYPE__ === 'undefined' ? 'production' : __API_TYPE__;\n\nexport const API_ORIGIN =\n  typeof __API_ORIGIN__ === 'undefined' ? 'localhost' : __API_ORIGIN__;\n\nexport const BUILD_TYPE =\n  typeof __BUILD_TYPE__ === 'undefined' ? 'production' : __BUILD_TYPE__;\n\nexport const BUILD_ORIGIN =\n  typeof __BUILD_ORIGIN__ === 'undefined' ? 'localhost' : __BUILD_ORIGIN__;\n\nexport const VERSION = typeof __VERSION__ === 'undefined' ? '1' : __VERSION__;\n\n// booleans\nexport const IS_HTTPS =\n  typeof __IS_HTTPS__ === 'undefined' ? true : __IS_HTTPS__;\n\nexport const LOGGING = typeof __LOGGING__ === 'undefined' ? true : __LOGGING__;\n\nexport const NO_DEV_PORT =\n  typeof __NO_DEV_PORT__ === 'undefined' ? false : __NO_DEV_PORT__;\n\n// See note at the top. Defined globals wont work for service workers but will work for builds.\nexport const IS_SERVICE_WORKER =\n  typeof __IS_SERVICE_WORKER__ === 'undefined'\n    ? typeof self !== 'undefined' &&\n      typeof ServiceWorkerGlobalScope !== 'undefined'\n    : __IS_SERVICE_WORKER__;\n","import {\n  DeliveryPlatformKind,\n  type DeliveryPlatformKindValue,\n} from '../models/DeliveryPlatformKind';\nimport { SubscriptionType } from '../subscriptions/constants';\nimport type { SubscriptionTypeValue } from '../subscriptions/types';\nimport { Browser } from '../useragent/constants';\nimport { getBrowserName, getBrowserVersion } from '../useragent/detect';\nimport { API_ORIGIN, API_TYPE, IS_SERVICE_WORKER } from '../utils/EnvVariables';\n\nexport const isBrowser = () => typeof window !== 'undefined';\n\nexport const hasSafariWindow = () =>\n  isBrowser() && typeof window.safari !== 'undefined';\n\nexport const supportsServiceWorkers = () => {\n  if (IS_SERVICE_WORKER) return true;\n  return typeof navigator !== 'undefined' && 'serviceWorker' in navigator;\n};\n\nexport const windowEnvString = IS_SERVICE_WORKER ? 'Service Worker' : 'Browser';\n\nexport const useSafariLegacyPush = () =>\n  isBrowser() && window.safari?.pushNotification != undefined;\n\nexport const supportsVapidPush =\n  typeof PushSubscriptionOptions !== 'undefined' &&\n  // eslint-disable-next-line no-prototype-builtins\n  PushSubscriptionOptions.prototype.hasOwnProperty('applicationServerKey');\n\nexport const useSafariVapidPush = () =>\n  getBrowserName() === Browser.Safari &&\n  supportsVapidPush &&\n  !useSafariLegacyPush();\n\n// for determing the api url\nconst API_URL_PORT = 3000;\nconst TURBINE_API_URL_PORT = 18080;\n\nexport const getOneSignalApiUrl = ({\n  action,\n  legacy = false,\n}: {\n  action?: string;\n  legacy?: boolean;\n} = {}): URL => {\n  // using if statements to have better dead code elimination\n  if (API_TYPE === 'development') {\n    return isTurbineEndpoint(action)\n      ? new URL(`http://${API_ORIGIN}:${TURBINE_API_URL_PORT}/api/v1/`)\n      : new URL(`http://${API_ORIGIN}:${API_URL_PORT}/api/v1/`);\n  }\n\n  if (API_TYPE === 'staging') return new URL(`https://${API_ORIGIN}/api/v1/`);\n\n  if (API_TYPE === 'production')\n    return new URL(\n      legacy ? 'https://onesignal.com/api/v1/' : 'https://api.onesignal.com/',\n    );\n\n  throw new Error('Invalid API type');\n};\n\nconst TURBINE_ENDPOINTS = ['outcomes', 'on_focus'];\nconst isTurbineEndpoint = (action?: string): boolean => {\n  if (!action) {\n    return false;\n  }\n\n  return TURBINE_ENDPOINTS.some(\n    (turbine_endpoint) => action.indexOf(turbine_endpoint) > -1,\n  );\n};\n\nexport const getSubscriptionType = (): SubscriptionTypeValue => {\n  const isFirefox = getBrowserName() === Browser.Firefox;\n  if (isFirefox) {\n    return SubscriptionType.FirefoxPush;\n  }\n  if (useSafariVapidPush()) {\n    return SubscriptionType.SafariPush;\n  }\n  if (useSafariLegacyPush()) {\n    return SubscriptionType.SafariLegacyPush;\n  }\n  // Other browsers, like Edge, are Chromium based so we consider them \"Chrome\".\n  return SubscriptionType.ChromePush;\n};\n\n/**\n * Get the legacy player.device_type\n * NOTE: Use getSubscriptionType() instead when possible.\n */\nexport function getDeviceType(): DeliveryPlatformKindValue {\n  switch (getSubscriptionType()) {\n    case SubscriptionType.FirefoxPush:\n      return DeliveryPlatformKind.Firefox;\n    case SubscriptionType.SafariLegacyPush:\n      return DeliveryPlatformKind.SafariLegacy;\n    case SubscriptionType.SafariPush:\n      return DeliveryPlatformKind.SafariVapid;\n  }\n  return DeliveryPlatformKind.ChromeLike;\n}\n\nexport function getDeviceOS(): string {\n  return String(getBrowserVersion());\n}\n\nexport function getDeviceModel(): string {\n  return navigator.platform;\n}\n","export const DeliveryPlatformKind = {\n  ChromeLike: 5,\n  SafariLegacy: 7,\n  Firefox: 8,\n  Email: 11,\n  SafariVapid: 17,\n} as const;\n\nexport type DeliveryPlatformKindValue =\n  (typeof DeliveryPlatformKind)[keyof typeof DeliveryPlatformKind];\n","import type { DelayedPromptTypeValue } from '../prompts/types';\nimport { InvalidChannelInputField } from './constants';\nimport type { InvalidChannelInputFieldValue } from './types';\n\nexport class SWRegistrationError extends Error {\n  public readonly status: number;\n  public readonly statusText: string;\n\n  constructor(status: number, statusText: string) {\n    super(`Registration of a Service Worker failed.`);\n    this.status = status;\n    this.statusText = statusText;\n  }\n}\n\nexport class ChannelCaptureError extends Error {\n  reason: InvalidChannelInputFieldValue;\n\n  constructor(invalidChannelInput: InvalidChannelInputFieldValue) {\n    let errorMessage;\n    switch (invalidChannelInput) {\n      case InvalidChannelInputField.InvalidEmail:\n        errorMessage = `Invalid email`;\n        break;\n      case InvalidChannelInputField.InvalidSms:\n        errorMessage = `Invalid sms`;\n        break;\n      case InvalidChannelInputField.InvalidEmailAndSms:\n        errorMessage = `Invalid email & sms`;\n        break;\n    }\n    super(errorMessage);\n    this.reason = invalidChannelInput;\n  }\n}\n\nexport const AppIDMissingError = new Error('Missing app ID');\n\nexport const RetryLimitError = new Error('Retry limit reached');\n\nexport const PermissionBlockedError = new Error('Permission blocked');\n\nexport const InvalidAppIdError = new Error(\"AppID doesn't match existing apps\");\n\nexport const SdkAlreadyInitializedError = new Error('SDK already initialized');\n\nexport const MissingSafariWebIdError = new Error(\n  'Safari web platform must be enabled',\n);\n\nexport const ExistingChannelError = (type: DelayedPromptTypeValue) =>\n  new Error(`Channel '${type}' already exists`);\n\nexport const EmptyArgumentError = (argName: string) =>\n  new Error(`\"${argName}\" is empty`);\n\nexport const MalformedArgumentError = (argName: string) =>\n  new Error(`\"${argName}\" is malformed`);\n\nexport const EnumOutOfRangeArgumentError = (argName: string) =>\n  new Error(`\"${argName}\" is out of range`);\n\nexport const WrongTypeArgumentError = (argName: string) =>\n  new Error(`\"${argName}\" is the wrong type`);\n\nexport const ReservedArgumentError = (argName: string) =>\n  new Error(`\"${argName}\" is reserved`);\n","/**\n * Returns a promise for the setTimeout() method.\n * @param durationMs\n * @returns {Promise} Returns a promise that resolves when the timeout is complete.\n */\nexport function delay(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function nothing(): Promise<any> {\n  return Promise.resolve();\n}\n\nexport function getValueOrDefault<T>(\n  value: T | undefined | null,\n  defaultValue: T,\n): T {\n  if (value !== undefined && value !== null) {\n    return value;\n  }\n  return defaultValue;\n}\n\nexport function getTimeZoneId() {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n\nexport function getBaseUrl() {\n  return location.origin;\n}\n","export interface ValidatorOptions {\n  allowNull?: boolean;\n  allowEmpty?: boolean;\n  /**\n   * For validating URLs, requires that the URL begins with https://.\n   */\n  requireHttps?: boolean;\n}\n\nexport function isObject(value: unknown) {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nexport function isValidEmail(email: string | undefined | null) {\n  return (\n    !!email &&\n    !!email.match(\n      // eslint-disable-next-line no-control-regex\n      /^([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22))*\\x40([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d))*$/,\n    )\n  );\n}\n\nexport function isValidUrl(\n  url: string | null | undefined,\n  options?: ValidatorOptions,\n) {\n  if (options && options.allowNull && url === null) return true;\n  else if (options && options.allowEmpty && (url === null || url === undefined))\n    return true;\n  else {\n    try {\n      const parsedUrl = new URL(url as string);\n      if (options && options.requireHttps) {\n        return parsedUrl.protocol === 'https:';\n      } else return true;\n    } catch (e) {\n      return false;\n    }\n  }\n}\n\n/**\n * Returns true if the UUID is a string of 36 characters;\n * @param uuid\n * @returns {*|boolean}\n */\nexport function isValidUuid(uuid: string) {\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(\n    uuid,\n  );\n}\n","import { IS_SERVICE_WORKER, LOGGING } from '../utils/EnvVariables';\n\nexport default class Log {\n  private static _shouldLog(): boolean {\n    if (IS_SERVICE_WORKER)\n      return !!(self as unknown as ServiceWorkerGlobalScope).shouldLog;\n    try {\n      /* LocalStorage may not be accessible on browser profiles that restrict 3rd party cookies */\n      const level = window.localStorage.getItem('loglevel');\n      return level?.toLowerCase() === 'trace';\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Sets the log level for page context.\n   * Will not do anything in service worker context.\n   */\n  public static _setLevel(level: string) {\n    if (IS_SERVICE_WORKER) return;\n\n    /* LocalStorage may not be accessible on browser profiles that restrict 3rd party cookies */\n    try {\n      window.localStorage.setItem('loglevel', level);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  private static _createLogMethod(consoleMethod: keyof Console) {\n    return (...args: unknown[]): void => {\n      if (LOGGING || this._shouldLog() || consoleMethod === 'error') {\n        (console[consoleMethod] as (...args: unknown[]) => void)(...args);\n      }\n    };\n  }\n  static _debug = Log._createLogMethod('debug');\n  static _info = Log._createLogMethod('info');\n  static _warn = Log._createLogMethod('warn');\n  static _error = Log._createLogMethod('error');\n}\n","import { RETRY_MS } from 'src/core/operationRepo/constants';\nimport { getOneSignalApiUrl } from '../environment/detect';\nimport { AppIDMissingError, RetryLimitError } from '../errors/common';\nimport { delay } from '../helpers/general';\nimport { isValidUuid } from '../helpers/validators';\nimport Log from '../libraries/Log';\nimport type { APIHeaders } from '../models/APIHeaders';\nimport { IS_SERVICE_WORKER, VERSION } from '../utils/EnvVariables';\n\ntype SupportedMethods = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\nexport interface OneSignalApiBaseResponse<T = unknown> {\n  ok: boolean;\n  result: T;\n  status: number;\n  retryAfterSeconds?: number;\n}\n\nconst getOrigin = () => {\n  if (IS_SERVICE_WORKER) {\n    return self.location.origin;\n  }\n  return window.location.origin;\n};\n\nexport function get<T>(\n  action: string,\n  data?: any,\n  headers?: APIHeaders | undefined,\n): Promise<OneSignalApiBaseResponse<T>> {\n  return call('GET', action, data, headers);\n}\n\nexport function post<T>(\n  action: string,\n  data?: any,\n  headers?: APIHeaders | undefined,\n): Promise<OneSignalApiBaseResponse<T>> {\n  return call('POST', action, data, headers);\n}\n\nexport function put<T>(\n  action: string,\n  data?: any,\n  headers?: APIHeaders | undefined,\n): Promise<OneSignalApiBaseResponse<T>> {\n  return call('PUT', action, data, headers);\n}\n\nfunction del<T>(\n  action: string,\n  data?: any,\n  headers?: APIHeaders | undefined,\n): Promise<OneSignalApiBaseResponse<T>> {\n  return call('DELETE', action, data, headers);\n}\n\n// since delete is a keyword, cant name function delete\nexport { del as delete };\n\nexport function patch<T = unknown>(\n  action: string,\n  data?: any,\n  headers?: APIHeaders | undefined,\n): Promise<OneSignalApiBaseResponse<T>> {\n  return call('PATCH', action, data, headers);\n}\n\nfunction call<T = unknown>(\n  method: SupportedMethods,\n  action: string,\n  data: any,\n  headers: APIHeaders | undefined,\n): Promise<OneSignalApiBaseResponse<T>> {\n  if (!requestHasAppId(action, data)) {\n    return Promise.reject(AppIDMissingError);\n  }\n\n  const callHeaders = new Headers();\n  callHeaders.append('Origin', getOrigin());\n  callHeaders.append('SDK-Version', `onesignal/web/${VERSION}`);\n  callHeaders.append('Content-Type', 'application/json;charset=UTF-8');\n  callHeaders.append('Accept', 'application/vnd.onesignal.v1+json');\n  if (headers) {\n    for (const key of Object.keys(headers)) {\n      callHeaders.append(key, headers[key]);\n    }\n  }\n\n  const contents: RequestInit = {\n    method: method || 'NO_METHOD_SPECIFIED',\n    headers: callHeaders,\n    cache: 'no-cache',\n  };\n  if (data) contents.body = JSON.stringify(data);\n\n  const url = `${getOneSignalApiUrl({\n    action,\n  }).toString()}${action}`;\n\n  return executeFetch(url, contents);\n}\n\nasync function executeFetch<T = unknown>(\n  url: string,\n  contents: RequestInit,\n  retry = 5,\n): Promise<OneSignalApiBaseResponse<T>> {\n  if (retry === 0) {\n    return Promise.reject(RetryLimitError);\n  }\n  try {\n    const response = await fetch(url, contents);\n    const { status, headers } = response;\n    const json = await response.json();\n    const retryAfter = headers?.get('Retry-After');\n    return {\n      ok: response.ok,\n      result: json,\n      status,\n      retryAfterSeconds: retryAfter ? parseInt(retryAfter) : undefined,\n    };\n  } catch (e) {\n    if (e instanceof Error && e.name === 'TypeError') {\n      // start with 10 seconds, then 20 seconds, then 30 seconds\n      await delay(retry > 3 ? (6 - retry) * RETRY_MS : 3 * RETRY_MS);\n      Log._error(\n        `OneSignal: Network timed out while calling ${url}. Retrying...`,\n      );\n      return executeFetch(url, contents, retry - 1);\n    }\n    throw new Error(`Failed to execute HTTP call: ${e}`);\n  }\n}\n\n// OneSignal's backend requires that all request have a\n// have a app_id in the UUID format in the request\nfunction requestHasAppId(url: string, body?: Record<string, unknown>): boolean {\n  if (url.startsWith('apps/')) {\n    const parts = url.split('/');\n    return isValidUuid(parts[1]);\n  }\n\n  // special case for sync\n  if (url.startsWith('sync/')) {\n    const parts = url.split('/');\n    return isValidUuid(parts[1]);\n  }\n\n  if (body && typeof body['app_id'] === 'string') {\n    return isValidUuid(body['app_id']);\n  }\n  return false;\n}\n","export const OPERATION_NAME = {\n  // Identity Operations\n  SET_ALIAS: 'set-alias',\n  DELETE_ALIAS: 'delete-alias',\n\n  // Property Operations\n  SET_PROPERTY: 'set-property',\n\n  // User Operations\n  REFRESH_USER: 'refresh-user',\n  LOGIN_USER: 'login-user',\n\n  // Subscription Operations\n  CREATE_SUBSCRIPTION: 'create-subscription',\n  UPDATE_SUBSCRIPTION: 'update-subscription',\n  DELETE_SUBSCRIPTION: 'delete-subscription',\n  TRANSFER_SUBSCRIPTION: 'transfer-subscription',\n\n  // Custom Events Operations\n  CUSTOM_EVENT: 'custom-event',\n} as const;\n\nexport const IdentityConstants = {\n  /**\n   * The alias label for the external ID alias.\n   */\n  EXTERNAL_ID: 'external_id',\n\n  /**\n   * The alias label for the internal OneSignal ID alias.\n   */\n  ONESIGNAL_ID: 'onesignal_id',\n} as const;\n","/**\n * Used for VAPID, converts the VAPID public key into a byte format the browser accepts.\n */\nexport function base64ToUint8Array(base64String: string): Uint8Array {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n\n  const rawData = atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent#encoding_for_rfc3986\nexport function encodeRFC3986URIComponent(str: string): string {\n  return encodeURIComponent(str).replace(\n    /[!'()*]/g,\n    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,\n  );\n}\n","import { InvalidAppIdError } from 'src/shared/errors/common';\nimport { isValidUuid } from 'src/shared/helpers/validators';\nimport type { OneSignalApiBaseResponse } from '../../shared/api/base';\nimport * as OneSignalApiBase from '../../shared/api/base';\nimport { encodeRFC3986URIComponent } from '../../shared/utils/Encoding';\nimport type {\n  AliasPair,\n  ICreateUser,\n  ICreateUserIdentity,\n  ICreateUserSubscription,\n  ISubscription,\n  IUpdateUser,\n  IUserIdentity,\n  IUserProperties,\n  RequestMetadata,\n  UserData,\n} from '../types/api';\nimport type { ICreateEvent } from '../types/customEvents';\n\n/**\n * Creates a new user\n * @param requestMetadata - { appId }\n * @param requestBody - The user's properties, identity, and subscriptions\n */\nexport async function createNewUser(\n  requestMetadata: RequestMetadata,\n  requestBody: ICreateUser,\n) {\n  const { appId, subscriptionId } = requestMetadata;\n\n  const subscriptionHeader = subscriptionId\n    ? { 'OneSignal-Subscription-Id': subscriptionId }\n    : undefined;\n\n  let headers = {};\n\n  if (subscriptionHeader) {\n    headers = { ...headers, ...subscriptionHeader };\n  }\n\n  if (requestMetadata.jwtHeader) {\n    headers = { ...headers, ...requestMetadata.jwtHeader };\n  }\n\n  requestBody['refresh_device_metadata'] = true;\n\n  return OneSignalApiBase.post<UserData>(\n    `apps/${appId}/users`,\n    requestBody,\n    headers,\n  );\n}\n\n/**\n * Returns the user's properties, aliases, and subscriptions\n * @param requestMetadata - { appId }\n * @param alias - The user's alias\n * @returns - A promise that resolves with the user's properties, identity, and subscriptions\n */\nexport async function getUserByAlias(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.get<UserData>(\n    `apps/${appId}/users/by/${alias.label}/${alias.id}`,\n    requestMetadata.jwtHeader,\n  );\n}\n\n/**\n * Updates an existing user's properties\n *  - Aliases and subscriptions are managed via other endpoints\n * @param requestMetadata - { appId }\n * @param alias - alias label & id\n * @param payload - update user payload\n * @returns no body\n */\nexport async function updateUserByAlias(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n  payload: IUpdateUser,\n) {\n  const { appId, subscriptionId } = requestMetadata;\n  if (!isValidUuid(appId)) {\n    throw InvalidAppIdError;\n  }\n\n  const subscriptionHeader = subscriptionId\n    ? { 'OneSignal-Subscription-Id': subscriptionId }\n    : undefined;\n\n  let headers = {};\n\n  if (subscriptionHeader) {\n    headers = { ...headers, ...subscriptionHeader };\n  }\n\n  if (requestMetadata.jwtHeader) {\n    headers = { ...headers, ...requestMetadata.jwtHeader };\n  }\n\n  const sanitizedAlias = {\n    label: encodeRFC3986URIComponent(alias.label),\n    id: encodeRFC3986URIComponent(alias.id),\n  };\n\n  return OneSignalApiBase.patch<{ properties: IUserProperties }>(\n    `apps/${appId}/users/by/${sanitizedAlias.label}/${sanitizedAlias.id}`,\n    payload,\n    headers,\n  );\n}\n\n/**\n * Removes the user identified by the given alias pair, and all subscriptions and aliases\n * @param requestMetadata - { appId }\n * @param alias - alias label & id\n */\nexport async function deleteUserByAlias(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n): Promise<OneSignalApiBaseResponse> {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.delete(\n    `apps/${appId}/users/by/${alias.label}/${alias.id}`,\n    requestMetadata.jwtHeader,\n  );\n}\n\n/* I D E N T I T Y   O P E R A T I O N S */\n\n/**\n * Upserts one or more aliases for the user identified by the given alias pair\n * @param requestMetadata - { appId }\n * @param alias - alias label & id\n * @param identity - identity label & id\n */\nexport async function addAlias(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n  identity: ICreateUserIdentity,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.patch<{ identity: IUserIdentity }>(\n    `apps/${appId}/users/by/${alias.label}/${alias.id}/identity`,\n    { identity },\n    requestMetadata.jwtHeader,\n  );\n}\n\n/**\n * Lists all aliases for the user identified by the given alias pair\n * @param requestMetadata - { appId }\n * @param alias - alias label & id\n */\nexport async function getUserIdentity(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n): Promise<OneSignalApiBaseResponse> {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.get<{ identity: IUserIdentity }>(\n    `apps/${appId}/users/by/${alias.label}/${alias.id}/identity`,\n    requestMetadata.jwtHeader,\n  );\n}\n\n/**\n * Deletes an alias for the user identified by the given alias pair\n * @param requestMetadata - { appId }\n * @param alias - alias label & id\n * @param labelToRemove - label of identity to remove\n */\nexport async function deleteAlias(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n  labelToRemove: string,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.delete<{ identity: IUserIdentity }>(\n    `apps/${appId}/users/by/${alias.label}/${alias.id}/identity/${labelToRemove}`,\n    requestMetadata.jwtHeader,\n  );\n}\n\n/* S U B S C R I P T I O N   O P E R A T I O N S */\n\n/**\n * Creates a new subscription for the user identified by the given alias pair\n * Useful to add email or SMS subscriptions to a user\n * @param requestMetadata - { appId }\n * @param alias - alias label & id\n * @param subscription - subscription label & id\n */\nexport async function createSubscriptionByAlias(\n  requestMetadata: RequestMetadata,\n  alias: AliasPair,\n  subscription: { subscription: ICreateUserSubscription },\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.post<{ subscription?: ISubscription }>(\n    `apps/${appId}/users/by/${alias.label}/${alias.id}/subscriptions`,\n    subscription,\n    requestMetadata.jwtHeader,\n  );\n}\n\n/**\n * Updates an existing Subscriptionâ€™s properties.\n * @param requestMetadata - { appId }\n * @param subscriptionId - subscription id\n * @param subscription - subscription object\n */\nexport async function updateSubscriptionById(\n  requestMetadata: RequestMetadata,\n  subscriptionId: string,\n  subscription: ICreateUserSubscription,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.patch<{\n    subscription: ISubscription;\n  }>(`apps/${appId}/subscriptions/${subscriptionId}`, { subscription });\n}\n\n/**\n * Deletes the subscription.\n * Creates an \"orphan\" user record if the user has no other subscriptions.\n * @param requestMetadata - { appId }\n * @param subscriptionId - subscription id\n */\nexport async function deleteSubscriptionById(\n  requestMetadata: RequestMetadata,\n  subscriptionId: string,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.delete<{ subscription: ISubscription }>(\n    `apps/${appId}/subscriptions/${subscriptionId}`,\n  );\n}\n\n/**\n * Transfers this Subscription to the User identified by the identity in the payload.\n * @param requestMetadata - { appId }\n * @param subscriptionId - subscription id\n * @param identity - identity label & id\n * @param retainPreviousOwner - if true *AND* subscription is last subscription for the previous\n * user, an orphan user will be created. Otherwise, the previous user will be deleted. Useful when going\n * from a guest (anonymous) user to an identified user. If the previous owner had other subscriptions,\n * nothing will happen to the previous user.\n */\nexport async function transferSubscriptionById(\n  requestMetadata: RequestMetadata,\n  subscriptionId: string,\n  identity: IUserIdentity,\n  retainPreviousOwner: boolean,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.patch<{ identity: IUserIdentity }>(\n    `apps/${appId}/subscriptions/${subscriptionId}/owner`,\n    {\n      identity: { ...identity },\n      retain_previous_owner: retainPreviousOwner,\n    },\n    requestMetadata.jwtHeader,\n  );\n}\n\n// custom events\nexport async function sendCustomEvent(\n  requestMetadata: RequestMetadata,\n  event: ICreateEvent,\n) {\n  const { appId } = requestMetadata;\n  return OneSignalApiBase.post(\n    `apps/${appId}/custom_events`,\n    {\n      events: [event],\n    },\n    requestMetadata.jwtHeader,\n  );\n}\n","import type { AliasPair } from 'src/core/types/api';\n\ninterface IndexOfAble {\n  indexOf(match: string): number;\n}\n\n/**\n * Returns true if match is in string; otherwise, returns false.\n */\nexport function containsMatch(\n  indexOfAble: IndexOfAble | null | undefined,\n  match: string,\n) {\n  if (!indexOfAble) return false;\n  return indexOfAble.indexOf(match) !== -1;\n}\n\n/**\n * JSON.stringify() but converts functions to \"[Function]\" so they aren't lost.\n * Helps when logging method calls.\n */\nexport function stringify(obj: any) {\n  return JSON.stringify(\n    obj,\n    (_, value) => {\n      if (typeof value === 'function') {\n        return '[Function]';\n      } else {\n        return value;\n      }\n    },\n    4,\n  );\n}\n\n/**\n * Used for generating query params\n *  e.g: -> hash = { appId } // with appId = '1234'\n *       -> returns \"appId=1234\"\n * @param  {any} hash\n * @returns string\n */\nexport function encodeHashAsUriComponent(hash: any): string {\n  let uriComponent = '';\n  const keys = Object.keys(hash);\n  for (const key of keys) {\n    const value = hash[key];\n    uriComponent += `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n  }\n  return uriComponent;\n}\n\nexport function timeoutPromise(\n  promise: Promise<any>,\n  milliseconds: number,\n): Promise<Error | any> {\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error('Async operation timed out'));\n    }, milliseconds);\n  });\n  return Promise.race([promise, timeoutPromise]);\n}\n\nexport function enforceAppId(appId: string | undefined | null): void {\n  if (!appId) {\n    throw new Error('App id cannot be empty');\n  }\n}\n\nexport function enforceAlias(aliasPair: AliasPair): void {\n  if (!aliasPair.label) {\n    throw new Error('Alias label cannot be empty');\n  }\n\n  if (!aliasPair.id) {\n    throw new Error('Alias id cannot be empty');\n  }\n}\n\nexport function sortArrayOfObjects<TObject, TProperty>(\n  arrayToSort: TObject[],\n  predicateForProperty: (obj: TObject) => TProperty,\n  descending = false,\n  doItInPlace = true,\n): TObject[] {\n  const internalArrayToSort = doItInPlace ? arrayToSort : arrayToSort.slice();\n  internalArrayToSort.sort((a: TObject, b: TObject) => {\n    const propertyA = predicateForProperty(a);\n    const propertyB = predicateForProperty(b);\n\n    if (propertyA > propertyB) {\n      return !!descending ? -1 : 1;\n    }\n    if (propertyA < propertyB) {\n      return !!descending ? 1 : -1;\n    }\n    return 0;\n  });\n  return internalArrayToSort;\n}\n","import { IdentityConstants } from 'src/core/constants';\nimport { updateUserByAlias } from 'src/core/requests/api';\nimport type { IUpdateUser } from 'src/core/types/api';\nimport type { ServerAppConfig } from '../config/types';\nimport { enforceAlias, enforceAppId } from '../context/helpers';\nimport { getSubscriptionType } from '../environment/detect';\nimport Log from '../libraries/Log';\nimport type { DeliveryPlatformKindValue } from '../models/DeliveryPlatformKind';\nimport {\n  OutcomeAttributionType,\n  type OutcomeAttribution,\n} from '../models/Outcomes';\nimport type { OutcomeRequestData } from '../outcomes/types';\nimport { NotificationType } from '../subscriptions/constants';\nimport * as OneSignalApiBase from './base';\nimport { sendOutcome } from './shared';\n\nexport async function downloadSWServerAppConfig(\n  appId: string,\n): Promise<ServerAppConfig> {\n  enforceAppId(appId);\n  const response = await OneSignalApiBase.get<ServerAppConfig>(\n    `sync/${appId}/web`,\n    null,\n  );\n  return response?.result;\n}\n\n/**\n * Given a GCM or Firefox subscription endpoint or Safari device token, returns the user ID from OneSignal's server.\n * Used if the user clears his or her IndexedDB database and we need the user ID again.\n */\nexport async function getUserIdFromSubscriptionIdentifier(\n  appId: string,\n  deviceType: DeliveryPlatformKindValue,\n  identifier: string,\n): Promise<string | null> {\n  // Calling POST /players with an existing identifier returns us that player ID\n  enforceAppId(appId);\n  return OneSignalApiBase.post<{ id: string }>('players', {\n    app_id: appId,\n    device_type: deviceType,\n    identifier: identifier,\n    notification_types: NotificationType.TemporaryWebRecord,\n  })\n    .then((response) => {\n      if (response?.result?.id) {\n        return response.result.id;\n      } else {\n        return null;\n      }\n    })\n    .catch((e) => {\n      Log._debug('Error getting user ID from subscription identifier:', e);\n      return null;\n    });\n}\n\n/**\n *  Main on_session call\n * @returns\n */\nexport async function updateUserSession(\n  appId: string,\n  onesignalId: string,\n  subscriptionId: string,\n): Promise<void> {\n  const aliasPair = {\n    label: IdentityConstants.ONESIGNAL_ID,\n    id: onesignalId,\n  };\n  // TO DO: in future, we should aggregate session count in case network call fails\n  const updateUserPayload: IUpdateUser = {\n    refresh_device_metadata: true,\n    deltas: {\n      session_count: 1,\n    },\n  };\n\n  enforceAppId(appId);\n  enforceAlias(aliasPair);\n  try {\n    await updateUserByAlias(\n      { appId, subscriptionId },\n      aliasPair,\n      updateUserPayload,\n    );\n  } catch (e) {\n    Log._debug('Error updating user session:', e);\n  }\n}\n\nexport async function sendSessionDuration(\n  appId: string,\n  onesignalId: string,\n  subscriptionId: string,\n  sessionDuration: number,\n  attribution: OutcomeAttribution,\n): Promise<void> {\n  const updateUserPayload: IUpdateUser = {\n    refresh_device_metadata: true,\n    deltas: {\n      session_time: sessionDuration,\n    },\n  };\n\n  const aliasPair = {\n    label: IdentityConstants.ONESIGNAL_ID,\n    id: onesignalId,\n  };\n\n  const outcomePayload: OutcomeRequestData = {\n    id: 'os__session_duration',\n    app_id: appId,\n    session_time: sessionDuration,\n    notification_ids: attribution.notificationIds,\n    subscription: {\n      id: subscriptionId,\n      type: getSubscriptionType(),\n    },\n    onesignal_id: onesignalId,\n  };\n\n  outcomePayload.direct =\n    attribution.type === OutcomeAttributionType.Direct ? true : false;\n\n  try {\n    await updateUserByAlias(\n      { appId, subscriptionId },\n      aliasPair,\n      updateUserPayload,\n    );\n\n    if (\n      outcomePayload.notification_ids &&\n      outcomePayload.notification_ids.length > 0\n    ) {\n      await sendOutcome(outcomePayload);\n    }\n  } catch (e) {\n    Log._debug('Error sending session duration:', e);\n  }\n}\n","export const DEFAULT_SERVICE_WORKER_OPTIONS = { scope: '/' };\nexport const DEFAULT_SERVICE_WORKER_PATH = 'OneSignalSDKWorker.js';\n","import type { SlidedownPromptOptions } from './types';\n\nexport const DelayedPromptType = {\n  Native: 'native', // native push\n  Push: 'push', // slidedown w/ push only\n  Category: 'category', // slidedown w/ push + categories\n  Sms: 'sms', // sms only\n  Email: 'email', // email only\n  SmsAndEmail: 'smsAndEmail', // sms and email only\n} as const;\n\nexport const SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS = {\n  pageViews: 1,\n  timeDelay: 0,\n};\n\nexport const SERVER_CONFIG_DEFAULTS_SLIDEDOWN = {\n  actionMessage:\n    \"We'd like to show you notifications for the latest news and updates.\",\n  acceptButton: 'Allow',\n  cancelButton: 'Cancel',\n  errorButton: 'Try Again',\n  categoryDefaults: {\n    updateMessage: 'Update your push notification subscription preferences.',\n    positiveUpdateButton: 'Save Preferences',\n    negativeUpdateButton: 'Cancel',\n  },\n  savingText: 'Saving...',\n  confirmMessage: 'Thank You!',\n};\n\nexport const CONFIG_DEFAULTS_SLIDEDOWN_OPTIONS: SlidedownPromptOptions = {\n  type: DelayedPromptType.Push,\n  text: {\n    actionMessage: SERVER_CONFIG_DEFAULTS_SLIDEDOWN.actionMessage,\n    acceptButton: SERVER_CONFIG_DEFAULTS_SLIDEDOWN.acceptButton,\n    cancelButton: SERVER_CONFIG_DEFAULTS_SLIDEDOWN.cancelButton,\n  },\n  autoPrompt: false, // default to false\n  delay: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS,\n};\n","export const NotificationClickMatchBehavior = {\n  Exact: 'exact',\n  Origin: 'origin',\n} as const;\n\nexport const NotificationClickActionBehavior = {\n  Navigate: 'navigate',\n  Focus: 'focus',\n} as const;\n\nexport const ConfigIntegrationKind = {\n  TypicalSite: 'typical',\n  WordPress: 'wordpress',\n  Custom: 'custom',\n} as const;\n","import { getValueOrDefault } from '../helpers/general';\nimport { SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS } from '../prompts/constants';\nimport type {\n  AppUserConfigCustomLinkOptions,\n  AppUserConfigPromptOptions,\n  SlidedownPromptOptions,\n} from '../prompts/types';\nimport type { ServerAppConfig } from './types';\n\n/**\n * Used only with Dashboard Configuration\n * @param  {ServerAppConfig} serverConfig\n * @returns AppUserConfigPromptOptions\n */\nexport function getPromptOptionsForDashboardConfiguration(\n  serverConfig: ServerAppConfig,\n): AppUserConfigPromptOptions {\n  const staticPrompts = serverConfig.config.staticPrompts;\n  const native = staticPrompts.native\n    ? {\n        enabled: staticPrompts.native.enabled,\n        autoPrompt:\n          staticPrompts.native.enabled &&\n          staticPrompts.native.autoPrompt !== false,\n        pageViews: getValueOrDefault(\n          staticPrompts.native.pageViews,\n          SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n        ),\n        timeDelay: getValueOrDefault(\n          staticPrompts.native.timeDelay,\n          SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay,\n        ),\n      }\n    : {\n        enabled: false,\n        autoPrompt: false,\n        pageViews: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n        timeDelay: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay,\n      };\n\n  const { prompts } = staticPrompts.slidedown;\n\n  return {\n    autoPrompt: native.autoPrompt || isSlidedownAutoPromptConfigured(prompts),\n    native,\n    slidedown: {\n      prompts,\n    },\n    fullscreen: {\n      enabled: staticPrompts.fullscreen.enabled,\n      actionMessage: staticPrompts.fullscreen.actionMessage,\n      acceptButton: staticPrompts.fullscreen.acceptButton,\n      cancelButton: staticPrompts.fullscreen.cancelButton,\n      title: staticPrompts.fullscreen.title,\n      message: staticPrompts.fullscreen.message,\n      caption: staticPrompts.fullscreen.caption,\n      autoAcceptTitle: staticPrompts.fullscreen.autoAcceptTitle,\n    },\n    customlink: getCustomLinkConfig(serverConfig),\n  };\n}\n\nexport function isSlidedownAutoPromptConfigured(\n  prompts: SlidedownPromptOptions[],\n): boolean {\n  if (!prompts) {\n    return false;\n  }\n\n  for (let i = 0; i < prompts.length; i++) {\n    if (prompts[i].autoPrompt) return true;\n  }\n  return false;\n}\n\nfunction getCustomLinkConfig(\n  serverConfig: ServerAppConfig,\n): AppUserConfigCustomLinkOptions {\n  const initialState: AppUserConfigCustomLinkOptions = {\n    enabled: false,\n    style: 'button',\n    size: 'medium',\n    unsubscribeEnabled: false,\n    text: {\n      explanation: '',\n      subscribe: '',\n      unsubscribe: '',\n    },\n    color: {\n      button: '',\n      text: '',\n    },\n  };\n\n  if (\n    !serverConfig ||\n    !serverConfig.config ||\n    !serverConfig.config.staticPrompts ||\n    !serverConfig.config.staticPrompts.customlink ||\n    !serverConfig.config.staticPrompts.customlink.enabled\n  ) {\n    return initialState;\n  }\n\n  const customlink = serverConfig.config.staticPrompts.customlink;\n\n  return {\n    enabled: customlink.enabled,\n    style: customlink.style,\n    size: customlink.size,\n    unsubscribeEnabled: customlink.unsubscribeEnabled,\n    text: customlink.text\n      ? {\n          subscribe: customlink.text.subscribe,\n          unsubscribe: customlink.text.unsubscribe,\n          explanation: customlink.text.explanation,\n        }\n      : initialState.text,\n    color: customlink.color\n      ? {\n          button: customlink.color.button,\n          text: customlink.color.text,\n        }\n      : initialState.color,\n  };\n}\n","import type { TagCategory } from 'src/page/tags/types';\nimport type {\n  AppUserConfig,\n  ConfigIntegrationKindValue,\n  ServerAppConfig,\n  ServiceWorkerConfigParams,\n} from 'src/shared/config/types';\nimport {\n  DEFAULT_SERVICE_WORKER_OPTIONS,\n  DEFAULT_SERVICE_WORKER_PATH,\n} from '../context/constants';\nimport { getValueOrDefault } from '../helpers/general';\nimport {\n  CONFIG_DEFAULTS_SLIDEDOWN_OPTIONS,\n  DelayedPromptType,\n  SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS,\n  SERVER_CONFIG_DEFAULTS_SLIDEDOWN,\n} from '../prompts/constants';\nimport type {\n  AppUserConfigCustomLinkOptions,\n  AppUserConfigPromptOptions,\n  ServerAppPromptConfig,\n} from '../prompts/types';\nimport { IS_SERVICE_WORKER } from '../utils/EnvVariables';\nimport { ConfigIntegrationKind } from './constants';\nimport {\n  getPromptOptionsForDashboardConfiguration,\n  isSlidedownAutoPromptConfigured,\n} from './prompt';\n\nconst MAX_CATEGORIES = 10;\n\nconst IntegrationConfigurationKind = {\n  /**\n   * Configuration comes from the dashboard only.\n   */\n  Dashboard: 0,\n  /**\n   * Configuration comes from user-provided JavaScript code only.\n   */\n  JavaScript: 1,\n} as const;\n\ntype IntegrationConfigurationKindValue =\n  (typeof IntegrationConfigurationKind)[keyof typeof IntegrationConfigurationKind];\n\ninterface IntegrationCapabilities {\n  configuration: IntegrationConfigurationKindValue;\n}\n\nexport function getConfigIntegrationKind(\n  serverConfig: ServerAppConfig,\n): ConfigIntegrationKindValue {\n  return serverConfig.config.integration?.kind ?? ConfigIntegrationKind.Custom;\n}\n\n/**\n * Describes how to merge a dashboard-set subdomain with a/lack of user-supplied subdomain.\n */\nexport function hasUnsupportedSubdomainForConfigIntegrationKind(\n  configIntegrationKind: ConfigIntegrationKindValue,\n  userConfig: AppUserConfig,\n  serverConfig: ServerAppConfig,\n): boolean {\n  const integrationCapabilities = getIntegrationCapabilities(\n    configIntegrationKind,\n  );\n\n  switch (integrationCapabilities.configuration) {\n    case IntegrationConfigurationKind.Dashboard:\n      return serverConfig.config.siteInfo.proxyOriginEnabled;\n    case IntegrationConfigurationKind.JavaScript:\n      return !!userConfig.subdomainName;\n  }\n}\n\nexport function getIntegrationCapabilities(\n  integration: ConfigIntegrationKindValue,\n): IntegrationCapabilities {\n  switch (integration) {\n    case ConfigIntegrationKind.Custom:\n    case ConfigIntegrationKind.WordPress:\n      return { configuration: IntegrationConfigurationKind.JavaScript };\n    default:\n      return { configuration: IntegrationConfigurationKind.Dashboard };\n  }\n}\n\nexport function getUserConfigForConfigIntegrationKind(\n  configIntegrationKind: ConfigIntegrationKindValue,\n  userConfig: AppUserConfig,\n  serverConfig: ServerAppConfig,\n): AppUserConfig {\n  const integrationCapabilities = getIntegrationCapabilities(\n    configIntegrationKind,\n  );\n  switch (integrationCapabilities.configuration) {\n    case IntegrationConfigurationKind.Dashboard: {\n      /*\n           Ignores code-based initialization configuration and uses dashboard configuration only.\n          */\n      const { path, serviceWorkerPath, serviceWorkerParam } =\n        getServiceWorkerValues(userConfig, serverConfig);\n\n      return {\n        appId: serverConfig.app_id,\n        autoRegister: false,\n        autoResubscribe: serverConfig.config.autoResubscribe,\n        path,\n        serviceWorkerPath,\n        serviceWorkerParam,\n        subdomainName: serverConfig.config.siteInfo.proxyOrigin,\n        promptOptions: getPromptOptionsForDashboardConfiguration(serverConfig),\n        welcomeNotification: {\n          disable: !serverConfig.config.welcomeNotification.enable,\n          title: serverConfig.config.welcomeNotification.title,\n          message: serverConfig.config.welcomeNotification.message,\n          url: serverConfig.config.welcomeNotification.url,\n        },\n        notifyButton: {\n          enable: serverConfig.config.staticPrompts.bell.enabled,\n          displayPredicate:\n            serverConfig.config.staticPrompts.bell.hideWhenSubscribed &&\n            !IS_SERVICE_WORKER\n              ? () => !OneSignal.User.PushSubscription.optedIn\n              : null,\n          size: serverConfig.config.staticPrompts.bell.size,\n          position: serverConfig.config.staticPrompts.bell.location,\n          showCredit: false,\n          offset: {\n            bottom: `${serverConfig.config.staticPrompts.bell.offset.bottom}px`,\n            left: `${serverConfig.config.staticPrompts.bell.offset.left}px`,\n            right: `${serverConfig.config.staticPrompts.bell.offset.right}px`,\n          },\n          colors: {\n            'circle.background':\n              serverConfig.config.staticPrompts.bell.color.main,\n            'circle.foreground':\n              serverConfig.config.staticPrompts.bell.color.accent,\n            'badge.background': 'black',\n            'badge.foreground': 'white',\n            'badge.bordercolor': 'black',\n            'pulse.color': serverConfig.config.staticPrompts.bell.color.accent,\n            'dialog.button.background.hovering':\n              serverConfig.config.staticPrompts.bell.color.main,\n            'dialog.button.background.active':\n              serverConfig.config.staticPrompts.bell.color.main,\n            'dialog.button.background':\n              serverConfig.config.staticPrompts.bell.color.main,\n            'dialog.button.foreground': 'white',\n          },\n          text: {\n            'tip.state.unsubscribed':\n              serverConfig.config.staticPrompts.bell.tooltip.unsubscribed,\n            'tip.state.subscribed':\n              serverConfig.config.staticPrompts.bell.tooltip.subscribed,\n            'tip.state.blocked':\n              serverConfig.config.staticPrompts.bell.tooltip.blocked,\n            'message.prenotify':\n              serverConfig.config.staticPrompts.bell.tooltip.unsubscribed,\n            'message.action.subscribing':\n              serverConfig.config.staticPrompts.bell.message.subscribing,\n            'message.action.subscribed':\n              serverConfig.config.staticPrompts.bell.message.subscribing,\n            'message.action.resubscribed':\n              serverConfig.config.staticPrompts.bell.message.subscribing,\n            'message.action.unsubscribed':\n              serverConfig.config.staticPrompts.bell.message.unsubscribing,\n            'dialog.main.title':\n              serverConfig.config.staticPrompts.bell.dialog.main.title,\n            'dialog.main.button.subscribe':\n              serverConfig.config.staticPrompts.bell.dialog.main\n                .subscribeButton,\n            'dialog.main.button.unsubscribe':\n              serverConfig.config.staticPrompts.bell.dialog.main\n                .unsubscribeButton,\n            'dialog.blocked.title':\n              serverConfig.config.staticPrompts.bell.dialog.blocked.title,\n            'dialog.blocked.message':\n              serverConfig.config.staticPrompts.bell.dialog.blocked.message,\n          },\n        },\n        persistNotification: serverConfig.config.notificationBehavior\n          ? serverConfig.config.notificationBehavior.display.persist\n          : undefined,\n        webhooks: {\n          cors: serverConfig.config.webhooks.corsEnable,\n          'notification.willDisplay':\n            serverConfig.config.webhooks.notificationDisplayedHook,\n          'notification.clicked':\n            serverConfig.config.webhooks.notificationClickedHook,\n          'notification.dismissed':\n            serverConfig.config.webhooks.notificationDismissedHook,\n        },\n        notificationClickHandlerMatch: serverConfig.config.notificationBehavior\n          ? serverConfig.config.notificationBehavior.click.match\n          : undefined,\n        notificationClickHandlerAction: serverConfig.config.notificationBehavior\n          ? serverConfig.config.notificationBehavior.click.action\n          : undefined,\n        outcomes: {\n          direct: serverConfig.config.outcomes.direct,\n          indirect: {\n            enabled: serverConfig.config.outcomes.indirect.enabled,\n            influencedTimePeriodMin:\n              serverConfig.config.outcomes.indirect.notification_attribution\n                .minutes_since_displayed,\n            influencedNotificationsLimit:\n              serverConfig.config.outcomes.indirect.notification_attribution\n                .limit,\n          },\n          unattributed: serverConfig.config.outcomes.unattributed,\n        },\n      };\n    }\n    case IntegrationConfigurationKind.JavaScript: {\n      /*\n            Ignores dashboard configuration and uses code-based configuration only.\n            Except injecting some default values for prompts.\n          */\n      const config = {\n        ...userConfig,\n        promptOptions: injectDefaultsIntoPromptOptions(\n          userConfig.promptOptions,\n          serverConfig.config.staticPrompts,\n          userConfig,\n        ),\n        ...{\n          serviceWorkerParam: !!userConfig.serviceWorkerParam\n            ? userConfig.serviceWorkerParam\n            : DEFAULT_SERVICE_WORKER_OPTIONS,\n          serviceWorkerPath: !!userConfig.serviceWorkerPath\n            ? userConfig.serviceWorkerPath\n            : DEFAULT_SERVICE_WORKER_PATH,\n          path: !!userConfig.path ? userConfig.path : '/',\n        },\n        outcomes: {\n          direct: serverConfig.config.outcomes.direct,\n          indirect: {\n            enabled: serverConfig.config.outcomes.indirect.enabled,\n            influencedTimePeriodMin:\n              serverConfig.config.outcomes.indirect.notification_attribution\n                .minutes_since_displayed,\n            influencedNotificationsLimit:\n              serverConfig.config.outcomes.indirect.notification_attribution\n                .limit,\n          },\n          unattributed: serverConfig.config.outcomes.unattributed,\n        },\n      };\n\n      if (Object.prototype.hasOwnProperty.call(userConfig, 'autoResubscribe')) {\n        config.autoResubscribe = !!userConfig.autoResubscribe;\n      } else if (\n        Object.prototype.hasOwnProperty.call(userConfig, 'autoRegister')\n      ) {\n        config.autoResubscribe = !!userConfig.autoRegister;\n      } else {\n        config.autoResubscribe = !!serverConfig.config.autoResubscribe;\n      }\n\n      return config;\n    }\n  }\n}\n\nfunction getServiceWorkerValues(\n  userConfig: AppUserConfig,\n  serverConfig: ServerAppConfig,\n): ServiceWorkerConfigParams {\n  const { serviceWorker } = serverConfig.config;\n  const useUserOverride = userConfig.serviceWorkerOverrideForTypical;\n\n  return {\n    path: useUserOverride\n      ? getValueOrDefault(userConfig.path, serviceWorker.path)\n      : serviceWorker.path,\n    serviceWorkerParam: useUserOverride\n      ? getValueOrDefault(userConfig.serviceWorkerParam, {\n          scope: serviceWorker.registrationScope,\n        })\n      : { scope: serviceWorker.registrationScope },\n    serviceWorkerPath: useUserOverride\n      ? getValueOrDefault(\n          userConfig.serviceWorkerPath,\n          serviceWorker.workerName,\n        )\n      : serviceWorker.workerName,\n  };\n}\n\n/**\n * Used for Custom Code Integration Type\n * @param  {AppUserConfigPromptOptions|undefined} promptOptions\n * @param  {ServerAppPromptConfig} defaultsFromServer\n * @param  {AppUserConfig} wholeUserConfig\n * @returns AppUserConfigPromptOptions\n */\nfunction injectDefaultsIntoPromptOptions(\n  promptOptions: AppUserConfigPromptOptions | undefined,\n  defaultsFromServer: ServerAppPromptConfig,\n  wholeUserConfig: AppUserConfig,\n): AppUserConfigPromptOptions | undefined {\n  let customlinkUser: AppUserConfigCustomLinkOptions = { enabled: false };\n  if (promptOptions && promptOptions.customlink) {\n    customlinkUser = promptOptions.customlink;\n  }\n  const customlinkDefaults = defaultsFromServer.customlink;\n  const promptOptionsConfig: AppUserConfigPromptOptions = {\n    ...promptOptions,\n    customlink: {\n      enabled: getValueOrDefault(\n        customlinkUser.enabled,\n        customlinkDefaults.enabled,\n      ),\n      style: getValueOrDefault(customlinkUser.style, customlinkDefaults.style),\n      size: getValueOrDefault(customlinkUser.size, customlinkDefaults.size),\n      unsubscribeEnabled: getValueOrDefault(\n        customlinkUser.unsubscribeEnabled,\n        customlinkDefaults.unsubscribeEnabled,\n      ),\n      text: {\n        subscribe: getValueOrDefault(\n          customlinkUser.text ? customlinkUser.text.subscribe : undefined,\n          customlinkDefaults.text.subscribe,\n        ),\n        unsubscribe: getValueOrDefault(\n          customlinkUser.text ? customlinkUser.text.unsubscribe : undefined,\n          customlinkDefaults.text.unsubscribe,\n        ),\n        explanation: getValueOrDefault(\n          customlinkUser.text ? customlinkUser.text.explanation : undefined,\n          customlinkDefaults.text.explanation,\n        ),\n      },\n      color: {\n        button: getValueOrDefault(\n          customlinkUser.color ? customlinkUser.color.button : undefined,\n          customlinkDefaults.color.button,\n        ),\n        text: getValueOrDefault(\n          customlinkUser.color ? customlinkUser.color.text : undefined,\n          customlinkDefaults.color.text,\n        ),\n      },\n    },\n  };\n\n  if (promptOptionsConfig.slidedown) {\n    promptOptionsConfig.slidedown.prompts =\n      promptOptionsConfig.slidedown?.prompts?.map((promptOption) => {\n        promptOption.type = getValueOrDefault(\n          promptOption.type,\n          DelayedPromptType.Push,\n        );\n\n        if (promptOption.type === DelayedPromptType.Category) {\n          promptOption.text = {\n            ...promptOption.text,\n            positiveUpdateButton: getValueOrDefault(\n              promptOption.text?.positiveUpdateButton,\n              SERVER_CONFIG_DEFAULTS_SLIDEDOWN.categoryDefaults\n                .positiveUpdateButton,\n            ),\n            negativeUpdateButton: getValueOrDefault(\n              promptOption.text?.negativeUpdateButton,\n              SERVER_CONFIG_DEFAULTS_SLIDEDOWN.categoryDefaults\n                .negativeUpdateButton,\n            ),\n            updateMessage: getValueOrDefault(\n              promptOption.text?.updateMessage,\n              SERVER_CONFIG_DEFAULTS_SLIDEDOWN.categoryDefaults.updateMessage,\n            ),\n          };\n        }\n\n        promptOption.text = {\n          ...promptOption.text,\n          actionMessage: getValueOrDefault(\n            promptOption.text?.actionMessage,\n            SERVER_CONFIG_DEFAULTS_SLIDEDOWN.actionMessage,\n          ),\n          acceptButton: getValueOrDefault(\n            promptOption.text?.acceptButton,\n            SERVER_CONFIG_DEFAULTS_SLIDEDOWN.acceptButton,\n          ),\n          cancelButton: getValueOrDefault(\n            promptOption.text?.cancelButton,\n            SERVER_CONFIG_DEFAULTS_SLIDEDOWN.cancelButton,\n          ),\n          confirmMessage: getValueOrDefault(\n            promptOption.text?.confirmMessage,\n            SERVER_CONFIG_DEFAULTS_SLIDEDOWN.confirmMessage,\n          ),\n        };\n\n        // default autoPrompt to true iff slidedown config exists but omitted the autoPrompt setting\n        promptOption.autoPrompt = getValueOrDefault(\n          promptOption.autoPrompt,\n          true,\n        );\n\n        promptOption.delay = {\n          pageViews: getValueOrDefault(\n            promptOption.delay?.pageViews,\n            SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n          ),\n          timeDelay: getValueOrDefault(\n            promptOption.delay?.timeDelay,\n            SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay,\n          ),\n        };\n\n        if (promptOption.categories) {\n          const { categories } = promptOption;\n          promptOption.categories = limitCategoriesToMaxCount(\n            categories,\n            MAX_CATEGORIES,\n          );\n        }\n\n        return promptOption;\n      });\n  } else {\n    promptOptionsConfig.slidedown = { prompts: [] };\n    promptOptionsConfig.slidedown.prompts = [CONFIG_DEFAULTS_SLIDEDOWN_OPTIONS];\n  }\n\n  if (promptOptionsConfig.native) {\n    const hasAutoPromptProperty = Object.prototype.hasOwnProperty.call(\n      promptOptionsConfig.native,\n      'autoPrompt',\n    );\n    promptOptionsConfig.native.autoPrompt = hasAutoPromptProperty\n      ? !!promptOptionsConfig.native.enabled &&\n        !!promptOptionsConfig.native.autoPrompt\n      : !!promptOptionsConfig.native.enabled;\n\n    promptOptionsConfig.native.enabled = !!promptOptionsConfig.native.enabled;\n\n    promptOptionsConfig.native.pageViews = getValueOrDefault(\n      promptOptionsConfig.native.pageViews,\n      SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n    );\n    promptOptionsConfig.native.timeDelay = getValueOrDefault(\n      promptOptionsConfig.native.timeDelay,\n      SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay,\n    );\n  } else {\n    promptOptionsConfig.native = {\n      enabled: false,\n      autoPrompt: false,\n      pageViews: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.pageViews,\n      timeDelay: SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS.timeDelay,\n    };\n  }\n\n  /**\n   * If autoRegister is true, show native prompt for https and slidedown for http ignoring any other related\n   * prompt options.\n   */\n  if (wholeUserConfig.autoRegister === true) {\n    //enable native prompt & make it autoPrompt\n    promptOptionsConfig.native.enabled = true;\n    promptOptionsConfig.native.autoPrompt = true;\n\n    //leave slidedown settings without change\n  }\n\n  // sets top level `autoPrompt` to trigger autoprompt codepath in initialization / prompting flow\n  promptOptionsConfig.autoPrompt =\n    promptOptionsConfig.native.autoPrompt ||\n    isSlidedownAutoPromptConfigured(promptOptionsConfig.slidedown.prompts);\n\n  return promptOptionsConfig;\n}\n\nexport function limitCategoriesToMaxCount(\n  tagCategories: TagCategory[],\n  max: number,\n): TagCategory[] {\n  return structuredClone(tagCategories).slice(0, max);\n}\n","import { downloadServerAppConfig } from '../api/page';\nimport { InvalidAppIdError } from '../errors/common';\nimport { getValueOrDefault } from '../helpers/general';\nimport { isValidUuid } from '../helpers/validators';\nimport { checkRestrictedOrigin, checkUnsupportedSubdomain } from './domain';\nimport {\n  getConfigIntegrationKind,\n  getUserConfigForConfigIntegrationKind,\n  hasUnsupportedSubdomainForConfigIntegrationKind,\n} from './integration';\nimport {\n  type AppConfig,\n  type AppUserConfig,\n  type ServerAppConfig,\n} from './types';\nimport { upgradeConfigToVersionTwo } from './version';\n\n// local constants\nconst SERVER_CONFIG_DEFAULTS_SESSION = {\n  reportingThreshold: 30,\n  enableOnSessionForUnsubcribed: false,\n  enableOnFocus: true,\n};\n\n// helpers\nexport async function getAppConfig(\n  userConfig: AppUserConfig,\n): Promise<AppConfig> {\n  return getServerAppConfig(userConfig, downloadServerAppConfig);\n}\n\nexport async function getServerAppConfig(\n  userConfig: AppUserConfig,\n  downloadConfig: (appId: string) => Promise<ServerAppConfig>,\n): Promise<AppConfig> {\n  try {\n    if (!userConfig || !userConfig.appId || !isValidUuid(userConfig.appId))\n      throw InvalidAppIdError;\n\n    const serverConfig = await downloadConfig(userConfig.appId);\n    upgradeConfigToVersionTwo(userConfig);\n    const appConfig = getMergedConfig(userConfig, serverConfig);\n\n    checkUnsupportedSubdomain(appConfig);\n    checkRestrictedOrigin(appConfig);\n    return appConfig;\n  } catch (e) {\n    if (e instanceof Object && 'code' in e) {\n      if (e.code === 1) throw InvalidAppIdError;\n      else if (e.code === 2) throw new Error('App not configured for web push');\n    }\n    throw e;\n  }\n}\n\n/**\n * Merges configuration downloaded from the OneSignal dashboard with user-provided JavaScript configuration to produce\n * a final web SDK-specific configuration.\n */\nexport function getMergedConfig(\n  userConfig: AppUserConfig,\n  serverConfig: ServerAppConfig,\n): AppConfig {\n  const configIntegrationKind = getConfigIntegrationKind(serverConfig);\n\n  const hasUnsupportedSubdomain =\n    hasUnsupportedSubdomainForConfigIntegrationKind(\n      configIntegrationKind,\n      userConfig,\n      serverConfig,\n    );\n\n  const mergedUserConfig = getUserConfigForConfigIntegrationKind(\n    configIntegrationKind,\n    userConfig,\n    serverConfig,\n  );\n\n  return {\n    appId: serverConfig.app_id,\n    hasUnsupportedSubdomain,\n    siteName: serverConfig.config.siteInfo.name,\n    origin: serverConfig.config.origin,\n    restrictedOriginEnabled:\n      serverConfig.features.restrict_origin &&\n      serverConfig.features.restrict_origin.enable,\n    safariWebId: serverConfig.config.safari_web_id,\n    vapidPublicKey: serverConfig.config.vapid_public_key,\n    onesignalVapidPublicKey: serverConfig.config.onesignal_vapid_public_key,\n    userConfig: mergedUserConfig,\n    enableOnSession: getValueOrDefault(\n      serverConfig.features.enable_on_session,\n      SERVER_CONFIG_DEFAULTS_SESSION.enableOnSessionForUnsubcribed,\n    ),\n    sessionThreshold: getValueOrDefault(\n      serverConfig.features.session_threshold,\n      SERVER_CONFIG_DEFAULTS_SESSION.reportingThreshold,\n    ),\n    enableSessionDuration: getValueOrDefault(\n      serverConfig.features.web_on_focus_enabled,\n      SERVER_CONFIG_DEFAULTS_SESSION.enableOnFocus,\n    ),\n  };\n}\n","import { DelayedPromptType } from '../prompts/constants';\nimport type {\n  AppUserConfigPromptOptions,\n  SlidedownOptions,\n  SlidedownOptionsVersion1,\n} from '../prompts/types';\nimport type { AppUserConfig } from './types';\n\n/**\n * Standardizes config to version 2 of the config schema\n * @param  {AppUserConfig} userConfig\n */\nexport function upgradeConfigToVersionTwo(userConfig: AppUserConfig) {\n  if (isPromptOptionsVersion0(userConfig.promptOptions)) {\n    userConfig.promptOptions = convertConfigToVersionOne(\n      userConfig.promptOptions,\n    );\n  }\n\n  if (isSlidedownConfigVersion1(userConfig.promptOptions?.slidedown)) {\n    if (userConfig.promptOptions?.slidedown) {\n      userConfig.promptOptions.slidedown = convertConfigToVersionTwo(\n        userConfig.promptOptions?.slidedown,\n      );\n    }\n  }\n}\n\n/**\n * For use with Custom Code & Wordpress Implementations\n * The OneSignal Wordpress Plugin still uses these legacy keys to set the slidedown text\n * @param  {any} slidedownConfig\n * @returns boolean\n */\nfunction isPromptOptionsVersion0(slidedownConfig: unknown): boolean {\n  if (!slidedownConfig) return false;\n\n  const version0Keys = [\n    'acceptButtonText',\n    'cancelButtonText',\n    'actionMessage',\n  ];\n\n  return version0Keys.some((key) =>\n    Object.prototype.hasOwnProperty.call(slidedownConfig, key),\n  );\n}\n\n/**\n * convertConfigToVersionOne - converts v0 schema to v1 schema format\n *\n * v0 schema example\n * ---\n *  promptOptions: {\n *      acceptButtonText: '',\n *      cancelButtonText: '',\n *      actionMessage   : '',\n *      slidedown: {...}\n *  }\n *\n * v1 schema example\n * ---\n * \"promptOptions\": {\n *    \"slidedown\": {\n *      \"enabled\": true,\n *      \"autoPrompt\": true,\n *      \"acceptButtonText\": \"\",\n *      \"cancelButtonText\": \"\",\n *      \"actionMessage\": \"\",\n *      \"...\",\n *    }\n * }\n * @param  {any} promptOptions\n * @returns AppUserConfigPromptOptions\n */\nfunction convertConfigToVersionOne(\n  promptOptions: any,\n): AppUserConfigPromptOptions {\n  if (!promptOptions.slidedown) {\n    promptOptions.slidedown = {};\n  }\n\n  const { slidedown } = promptOptions;\n\n  /**\n   * we should give preference to the lower level (\"slidedown\" level) text settings in the case that\n   * text settings are configured at the higher level as well as the lower level\n   *\n   * Example:\n   * \"promptOptions\": {\n   *      \"acceptButtonText\": \"\",\n   *      \"cancelButtonText\": \"\",\n   *      \"slidedown\": {\n   *          \"acceptButtonText\": \"\", <--\n   *          \"cancelButtonText\": \"\"  <--\n   *      }\n   * }\n   */\n  slidedown.acceptButtonText =\n    slidedown.acceptButtonText ??\n    promptOptions.acceptButtonText ??\n    promptOptions.acceptButton;\n\n  slidedown.cancelButtonText =\n    slidedown.cancelButtonText ??\n    promptOptions.cancelButtonText ??\n    promptOptions.cancelButton;\n\n  slidedown.actionMessage =\n    slidedown.actionMessage ?? promptOptions.actionMessage;\n\n  return promptOptions;\n}\n\n/**\n * For use with Custom Code Implementations\n * Checks whether `slidedownConfig` implements `SlidedownOptionsVersion1` interface\n * ------------------------------\n * v1 schema:\n * ----------\n * \"slidedown\": {\n *    \"enabled\": true,\n *    \"autoPrompt\": true,\n *    \"...\",\n *    \"categories\": {...}\n * }\n *\n * v2 schema:\n * ----------\n * \"slidedown\": {\n *    \"prompts\": [{...}, {...}, {...}]\n * }\n *\n * Since config can also be set via custom-code and we have no strict checks,\n * this function helps to check whether the config implements any v1 style config options\n * by looking for any of the v1 payload first-level keys. See `SlidedownOptionsVersion1`\n * for the full list of keys.\n * @param slidedownConfig\n */\nfunction isSlidedownConfigVersion1(\n  slidedownConfig: any,\n): slidedownConfig is SlidedownOptionsVersion1 {\n  if (!slidedownConfig) return false;\n\n  const version1Keys = [\n    'enabled',\n    'autoPrompt',\n    'pageViews',\n    'timeDelay',\n    'acceptButton',\n    'acceptButtonText',\n    'cancelButton',\n    'cancelButtonText',\n    'actionMessage',\n    'customizeTextEnabled',\n    'categories',\n  ] as const;\n\n  return version1Keys.some((key) =>\n    Object.prototype.hasOwnProperty.call(slidedownConfig, key),\n  );\n}\n\nfunction convertConfigToVersionTwo(\n  slidedownConfig: SlidedownOptionsVersion1 & SlidedownOptions,\n): SlidedownOptions {\n  const isCategory = isCategorySlidedownConfiguredVersion1(slidedownConfig);\n  const promptType = isCategory\n    ? DelayedPromptType.Category\n    : DelayedPromptType.Push;\n\n  const { categories, prompts = [] } = slidedownConfig;\n\n  const newPrompt = {\n    type: promptType,\n    autoPrompt: slidedownConfig.autoPrompt,\n    text: {\n      actionMessage: slidedownConfig.actionMessage,\n      acceptButton:\n        slidedownConfig.acceptButton ?? slidedownConfig.acceptButtonText,\n      cancelButton:\n        slidedownConfig.cancelButton ?? slidedownConfig.cancelButtonText,\n      ...(isCategory && {\n        positiveUpdateButton: categories?.positiveUpdateButton,\n        negativeUpdateButton: categories?.negativeUpdateButton,\n        updateMessage: categories?.updateMessage,\n      }),\n    },\n    delay: {\n      pageViews: slidedownConfig.pageViews,\n      timeDelay: slidedownConfig.timeDelay,\n    },\n    categories: categories?.tags,\n  };\n\n  return {\n    prompts: [...prompts, newPrompt],\n  } as SlidedownOptions;\n}\n\n/**\n * Is Category Slidedown Configured (version 1 config schema)\n * @param  {SlidedownOptionsVersion1} options\n * @returns boolean\n */\nfunction isCategorySlidedownConfiguredVersion1(\n  options?: SlidedownOptionsVersion1,\n): boolean {\n  return (options?.categories?.tags?.length || 0) > 0;\n}\n","import { IS_SERVICE_WORKER } from 'src/shared/utils/EnvVariables';\nimport { type AppConfig } from './types';\n\n// The os.tc domain feature is no longer supported in v16, so throw if the\n// OneSignal app is still configured this way after they migrated from v15.\nexport function checkUnsupportedSubdomain(appConfig: AppConfig): void {\n  const isHttp = !self.isSecureContext;\n  const unsupportedEnv = appConfig.hasUnsupportedSubdomain || isHttp;\n\n  if (unsupportedEnv) {\n    if (isHttp) {\n      throw new Error(\n        'OneSignalSDK: HTTP sites are no longer supported starting with version 16 (User Model), your public site must start with https://.',\n      );\n    } else {\n      throw new Error(\n        'OneSignalSDK: The \"My site is not fully HTTPS\" option is no longer supported starting with version 16 (User Model) of the OneSignal SDK.',\n      );\n    }\n  }\n}\n\nexport function checkRestrictedOrigin(appConfig: AppConfig) {\n  if (!appConfig.restrictedOriginEnabled) return;\n\n  if (IS_SERVICE_WORKER) return;\n\n  if (!doesCurrentOriginMatchConfigOrigin(appConfig.origin)) {\n    throw new Error(`Can only be used on: ${new URL(appConfig.origin).origin}`);\n  }\n}\n\nfunction doesCurrentOriginMatchConfigOrigin(configOrigin: string): boolean {\n  try {\n    return location.origin === new URL(configOrigin).origin;\n  } catch (e) {\n    return false;\n  }\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","export const ONESIGNAL_SESSION_KEY = 'oneSignalSession';\n\nexport const SessionStatus = {\n  Active: 'active',\n  Inactive: 'inactive',\n} as const;\n\nexport const SessionOrigin = {\n  UserCreate: 1,\n  UserNewSession: 2,\n  VisibilityVisible: 3,\n  VisibilityHidden: 4,\n  BeforeUnload: 5,\n  Focus: 7,\n  Blur: 8,\n} as const;\n","import { openDB } from 'idb';\nimport Log from '../libraries/Log';\nimport { ONESIGNAL_SESSION_KEY } from '../session/constants';\nimport { IS_SERVICE_WORKER } from '../utils/EnvVariables';\nimport { DATABASE_NAME, VERSION } from './constants';\nimport type { IDBStoreName, IdKey, IndexedDBSchema, OptionKey } from './types';\nimport {\n  migrateModelNameSubscriptionsTableForV6,\n  migrateOutcomesNotificationClickedTableForV5,\n  migrateOutcomesNotificationReceivedTableForV5,\n} from './upgrade';\n\nlet terminated = false;\nconst open = async (version = VERSION) => {\n  return openDB<IndexedDBSchema>(DATABASE_NAME, version, {\n    upgrade(_db, oldVersion, newVersion, transaction) {\n      const newDbVersion = newVersion || version;\n      if (newDbVersion >= 1 && oldVersion < 1) {\n        _db.createObjectStore('Ids', { keyPath: 'type' });\n        _db.createObjectStore('NotificationOpened', { keyPath: 'url' });\n        _db.createObjectStore('Options', { keyPath: 'key' });\n      }\n\n      if (newDbVersion >= 2 && oldVersion < 2) {\n        _db.createObjectStore('Sessions', { keyPath: 'sessionKey' });\n        _db.createObjectStore('NotificationReceived', {\n          keyPath: 'notificationId',\n        });\n        // NOTE: 160000.beta4 to 160000 releases modified this line below as\n        // \"{ keyPath: \"notification.id\" }\". This resulted in DB v4 either\n        // having \"notificationId\" or \"notification.id\" depending if the visitor\n        // was new while this version was live.\n        // DB v5 was created to trigger a migration to fix this bug.\n        _db.createObjectStore('NotificationClicked', {\n          keyPath: 'notificationId',\n        });\n      }\n\n      if (newDbVersion >= 3 && oldVersion < 3) {\n        _db.createObjectStore('SentUniqueOutcome', { keyPath: 'outcomeName' });\n      }\n\n      if (newDbVersion >= 4 && oldVersion < 4) {\n        _db.createObjectStore('identity', { keyPath: 'modelId' });\n        _db.createObjectStore('properties', { keyPath: 'modelId' });\n        _db.createObjectStore('pushSubscriptions', {\n          keyPath: 'modelId',\n        });\n        _db.createObjectStore('smsSubscriptions', {\n          keyPath: 'modelId',\n        });\n        _db.createObjectStore('emailSubscriptions', {\n          keyPath: 'modelId',\n        });\n      }\n\n      if (newDbVersion >= 5 && oldVersion < 5) {\n        migrateOutcomesNotificationClickedTableForV5(_db, transaction);\n        migrateOutcomesNotificationReceivedTableForV5(_db, transaction);\n      }\n\n      if (newDbVersion >= 6 && oldVersion < 6) {\n        migrateModelNameSubscriptionsTableForV6(_db, transaction);\n      }\n\n      if (newDbVersion >= 7 && oldVersion < 7) {\n        _db.createObjectStore('operations', { keyPath: 'modelId' });\n      }\n\n      // TODO: next version delete NotificationOpened table\n      terminated = false;\n      if (!IS_SERVICE_WORKER && typeof OneSignal !== 'undefined') {\n        OneSignal._isNewVisitor = true;\n      }\n    },\n    blocked() {\n      Log._debug('IndexedDB: Blocked event');\n    },\n    terminated() {\n      // reopen if db was terminated\n      if (!terminated) {\n        terminated = true;\n        getDb();\n      }\n    },\n  });\n};\nlet dbPromise = open();\n\nexport const getDb = (version = VERSION) => {\n  dbPromise = open(version);\n  return dbPromise;\n};\n\n// Export db object with the same API as before\nexport const db = {\n  async get<K extends IDBStoreName>(\n    storeName: K,\n    key: IndexedDBSchema[K]['key'],\n  ): Promise<IndexedDBSchema[K]['value'] | undefined> {\n    return (await dbPromise).get(storeName, key);\n  },\n  async getAll<K extends IDBStoreName>(\n    storeName: K,\n  ): Promise<IndexedDBSchema[K]['value'][]> {\n    return (await dbPromise).getAll(storeName);\n  },\n  async put<K extends IDBStoreName>(\n    storeName: K,\n    value: IndexedDBSchema[K]['value'],\n  ) {\n    return (await dbPromise).put(storeName, value);\n  },\n  async delete<K extends IDBStoreName>(\n    storeName: K,\n    key: IndexedDBSchema[K]['key'],\n  ) {\n    return (await dbPromise).delete(storeName, key);\n  },\n};\n\nexport const clearStore = async <K extends IDBStoreName>(storeName: K) => {\n  return (await dbPromise).clear(storeName);\n};\n\nexport const getObjectStoreNames = async () => {\n  return Array.from((await dbPromise).objectStoreNames);\n};\n\nexport const getOptionsValue = async <T extends unknown>(\n  key: OptionKey,\n): Promise<T | null> => {\n  const result = await db.get('Options', key);\n  if (result && 'value' in result) return result.value as T;\n  return null;\n};\n\nexport const getIdsValue = async <T>(key: IdKey): Promise<T | null> => {\n  const result = await db.get('Ids', key);\n  if (result && 'id' in result) return result.id as T;\n  return null;\n};\n\nexport const getCurrentSession = async () => {\n  return (await db.get('Sessions', ONESIGNAL_SESSION_KEY)) ?? null;\n};\n\nexport const cleanupCurrentSession = async () => {\n  await db.delete('Sessions', ONESIGNAL_SESSION_KEY);\n};\n\nexport const clearAll = async () => {\n  const objectStoreNames = await getObjectStoreNames();\n  for (const storeName of objectStoreNames) {\n    await clearStore(storeName);\n  }\n};\n\nexport const closeDb = async () => {\n  (await dbPromise).close();\n};\n","export const DATABASE_NAME = 'ONE_SIGNAL_SDK_DB';\n\nexport const VERSION = 7;\n","import type { IDBPDatabase, IDBPTransaction } from 'idb';\nimport type { IndexedDBSchema } from './types';\n\ntype Transaction = IDBPTransaction<IndexedDBSchema, any[], 'versionchange'>;\n\n// Table rename \"NotificationClicked\" -> \"Outcomes.NotificationClicked\"\n// and migrate existing records.\n// Motivation: This is done to correct the keyPath, you can't change it\n// so a new table must be created.\n// Background: Table was created with wrong keyPath of \"notification.id\"\n// for new visitors for versions 160000.beta4 to 160000.beta8. Writes were\n// attempted as \"notificationId\" in released 160000 however they may\n// have failed if the visitor was new when those releases were in the wild.\n// However those new on 160000.beta4 to 160000.beta8 will have records\n// saved as \"notification.id\" that will be converted here.\nexport async function migrateOutcomesNotificationClickedTableForV5(\n  db: IDBPDatabase<IndexedDBSchema>,\n  transaction: Transaction,\n) {\n  const oldTableName = 'NotificationClicked';\n  const newTableName = 'Outcomes.NotificationClicked';\n\n  db.createObjectStore(newTableName, { keyPath: 'notificationId' });\n  let cursor = await transaction.objectStore(oldTableName).openCursor();\n\n  while (cursor) {\n    const oldValue = cursor.value;\n\n    await transaction.objectStore(newTableName).put({\n      // notification.id was possible from 160000.beta4 to 160000.beta8\n      notificationId: oldValue.notificationId || oldValue.notification.id,\n      appId: oldValue.appId,\n      timestamp: oldValue.timestamp,\n    });\n\n    cursor = await cursor.continue();\n  }\n  db.deleteObjectStore(oldTableName);\n}\n\n// Table rename \"NotificationReceived\" -> \"Outcomes.NotificationReceived\"\n// and migrate existing records.\n// Motivation: Consistency of using pre-fix \"Outcomes.\" like we have for\n// the \"Outcomes.NotificationClicked\" table.\nexport async function migrateOutcomesNotificationReceivedTableForV5(\n  db: IDBPDatabase<IndexedDBSchema>,\n  transaction: Transaction,\n) {\n  const oldTableName = 'NotificationReceived';\n  const newTableName = 'Outcomes.NotificationReceived';\n  db.createObjectStore(newTableName, { keyPath: 'notificationId' });\n\n  let cursor = await transaction.objectStore(oldTableName).openCursor();\n  while (cursor) {\n    await transaction.objectStore(newTableName).put(cursor.value);\n    cursor = await cursor.continue();\n  }\n  db.deleteObjectStore(oldTableName);\n}\n\nexport async function migrateModelNameSubscriptionsTableForV6(\n  db: IDBPDatabase<IndexedDBSchema>,\n  transaction: Transaction,\n) {\n  const newTableName = 'subscriptions';\n  db.createObjectStore(newTableName, { keyPath: 'modelId' });\n\n  let currentExternalId: string | undefined;\n  const identityData = await transaction.objectStore('identity').getAll();\n\n  if (identityData.length > 0) {\n    currentExternalId = identityData[0].externalId;\n  }\n\n  for (const legacyModelName of [\n    'emailSubscriptions',\n    'pushSubscriptions',\n    'smsSubscriptions',\n  ] as const) {\n    let cursor = await transaction.objectStore(legacyModelName).openCursor();\n    while (cursor) {\n      await transaction.objectStore(newTableName).put({\n        ...cursor.value,\n        modelName: 'subscriptions',\n        externalId: currentExternalId,\n      });\n      cursor = await cursor.continue();\n    }\n    db.deleteObjectStore(legacyModelName);\n  }\n}\n","import {\n  notificationClickedForOutcomesFromDatabase,\n  notificationClickedForOutcomesToDatabase,\n  notificationReceivedForOutcomesFromDatabase,\n  notificationReceivedForOutcomesToDatabase,\n} from '../helpers/serializer';\nimport type {\n  OutcomesNotificationClicked,\n  OutcomesNotificationReceived,\n} from '../models/OutcomesNotificationEvents';\nimport type {\n  IOSNotification,\n  NotificationClickEventInternal,\n} from '../notifications/types';\nimport { db } from './client';\n\nexport const putNotificationClickedForOutcomes = async (\n  appId: string,\n  event: NotificationClickEventInternal,\n) => {\n  await db.put(\n    'Outcomes.NotificationClicked',\n    notificationClickedForOutcomesToDatabase(appId, event),\n  );\n};\n\nexport const putNotificationReceivedForOutcomes = async (\n  appId: string,\n  notification: IOSNotification,\n) => {\n  await db.put(\n    'Outcomes.NotificationReceived',\n    notificationReceivedForOutcomesToDatabase(appId, notification, Date.now()),\n  );\n};\n\nexport const getAllNotificationClickedForOutcomes = async (): Promise<\n  OutcomesNotificationClicked[]\n> => {\n  const notifications = await db.getAll('Outcomes.NotificationClicked');\n  return notifications.map((notification) =>\n    notificationClickedForOutcomesFromDatabase(notification),\n  );\n};\n\nexport const getAllNotificationReceivedForOutcomes = async (): Promise<\n  OutcomesNotificationReceived[]\n> => {\n  const notifications = await db.getAll('Outcomes.NotificationReceived');\n  return notifications.map((notification) =>\n    notificationReceivedForOutcomesFromDatabase(notification),\n  );\n};\n","import type {\n  OutcomesNotificationClicked,\n  OutcomesNotificationReceived,\n} from '../models/OutcomesNotificationEvents';\nimport type {\n  IOSNotification,\n  IOSNotificationActionButton,\n  NotificationClickEventInternal,\n} from '../notifications/types';\n/**\n * Purpose: This file defines mapping so any changes to the public\n * classes don't break indexDb serialization.\n *\n * Naming Rules:\n *    1. All classes that convert types to / from the db\n *    must end in Serialize.\n *    2. All interfaces used with classes ending in Serialize\n *    must end in Schema.\n *\n * NOTE: Any change made to interfaces that end in Schema require\n *       bumping the indexDb.ts version and creating a migration.\n */\n\n// Purpose: Used to fire the 'click' event and open a page it's URL.\n//    * Only used if no pages are open for the website\nexport interface NotificationClickForOpenHandlingSchema {\n  readonly id: string; // indexDb's keyPath\n  readonly heading?: string;\n  readonly content: string;\n  readonly data?: object;\n  readonly url?: string;\n  readonly rr: boolean;\n  readonly icon?: string;\n  readonly image?: string;\n  readonly tag?: string;\n  readonly badge?: string;\n  readonly action?: string;\n  readonly buttons?: NotificationButtonsClickForOpenHandlingSchema[];\n  readonly timestamp: number;\n}\n\ninterface NotificationButtonsClickForOpenHandlingSchema {\n  readonly action: string;\n  readonly title: string;\n  readonly icon?: string;\n  readonly url?: string;\n}\n\nexport function notificationClickToDatabase(\n  event: NotificationClickEventInternal,\n): NotificationClickForOpenHandlingSchema {\n  const notification = event.notification;\n  const result = event.result;\n  return {\n    action: result.actionId,\n    badge: notification.badgeIcon,\n    buttons: toDatabaseButtons(notification.actionButtons),\n    content: notification.body,\n    data: notification.additionalData,\n    heading: notification.title,\n    icon: notification.icon,\n    id: notification.notificationId,\n    image: notification.image,\n    rr: notification.confirmDelivery,\n    tag: notification.topic,\n    timestamp: event.timestamp,\n    url: result.url,\n  };\n}\n\nfunction toDatabaseButtons(\n  actionButtons?: IOSNotificationActionButton[],\n): NotificationButtonsClickForOpenHandlingSchema[] | undefined {\n  return actionButtons?.map(\n    (button): NotificationButtonsClickForOpenHandlingSchema => ({\n      action: button.actionId,\n      title: button.text,\n      icon: button.icon,\n      url: button.launchURL,\n    }),\n  );\n}\n\nexport interface NotificationClickedForOutcomesSchema {\n  readonly appId: string;\n  readonly notificationId: string; // indexDb's keyPath\n  readonly timestamp: number;\n}\n\nexport function notificationClickedForOutcomesToDatabase(\n  appId: string,\n  event: NotificationClickEventInternal,\n): NotificationClickedForOutcomesSchema {\n  return {\n    appId: appId,\n    notificationId: event.notification.notificationId,\n    timestamp: event.timestamp,\n  };\n}\n\nexport function notificationClickedForOutcomesFromDatabase(\n  record: NotificationClickedForOutcomesSchema,\n): OutcomesNotificationClicked {\n  return {\n    appId: record.appId,\n    notificationId: record.notificationId,\n    timestamp: record.timestamp,\n  };\n}\n\nexport interface NotificationReceivedForOutcomesSchema {\n  readonly appId: string;\n  readonly notificationId: string; // indexDb's keyPath\n  readonly timestamp: number;\n}\n\nexport function notificationReceivedForOutcomesToDatabase(\n  appId: string,\n  notification: IOSNotification,\n  timeStamp: number,\n): NotificationReceivedForOutcomesSchema {\n  return {\n    appId: appId,\n    notificationId: notification.notificationId,\n    timestamp: timeStamp,\n  };\n}\n\nexport function notificationReceivedForOutcomesFromDatabase(\n  record: NotificationReceivedForOutcomesSchema,\n): OutcomesNotificationReceived {\n  return {\n    appId: record.appId,\n    notificationId: record.notificationId,\n    timestamp: record.timestamp,\n  };\n}\n","import type { Serializable } from '../../page/models/Serializable';\n\nexport class Subscription implements Serializable {\n  /**\n   * The OneSignal subscription id.\n   */\n  deviceId: string | null | undefined;\n  /**\n   * The GCM/FCM registration token, as a stringified URL, or the Safari device token.\n   */\n  subscriptionToken: string | null | undefined;\n  /**\n   * Whether the user is opted out of notifications, set by setSubscription().\n   */\n  optedOut: boolean | undefined;\n  /**\n   * A UTC timestamp of when this subscription was created. This value is not modified when a\n   * subscription is merely refreshed, only when a subscription is created anew.\n   */\n  createdAt: number | null | undefined;\n  /**\n   * This property is stored on the native PushSubscription object.\n   */\n  expirationTime: number | null | undefined;\n\n  _serialize() {\n    return {\n      deviceId: this.deviceId,\n      subscriptionToken: this.subscriptionToken,\n      optedOut: this.optedOut,\n      createdAt: this.createdAt,\n      expirationTime: this.expirationTime,\n    };\n  }\n\n  static _deserialize(bundle: any): Subscription {\n    const subscription = new Subscription();\n    subscription.deviceId = bundle.deviceId;\n    subscription.subscriptionToken = bundle.subscriptionToken;\n    subscription.optedOut = bundle.optedOut;\n    subscription.createdAt = bundle.createdAt;\n    subscription.expirationTime = bundle.expirationTime;\n    return subscription;\n  }\n}\n","import { Subscription } from '../models/Subscription';\nimport { db, getOptionsValue } from './client';\n\nexport const getPushId = async () => {\n  return await getOptionsValue<string>('lastPushId');\n};\nexport const setPushId = async (pushId: string | undefined) => {\n  await db.put('Options', { key: 'lastPushId', value: pushId });\n};\n\nexport const getPushToken = async () => {\n  return await getOptionsValue<string>('lastPushToken');\n};\nexport const setPushToken = async (pushToken: string | undefined) => {\n  await db.put('Options', { key: 'lastPushToken', value: pushToken });\n};\n\nexport const getSubscription = async () => {\n  const subscription = new Subscription();\n  subscription.deviceId = (await db.get('Ids', 'userId'))?.id;\n  subscription.subscriptionToken = (await db.get('Ids', 'registrationId'))?.id;\n\n  // The preferred database key to store our subscription\n  const dbOptedOut = await getOptionsValue<boolean>('optedOut');\n  // For backwards compatibility, we need to read from this if the above is not found\n  const dbNotOptedOut = await getOptionsValue<boolean>('subscription');\n  const createdAt = await getOptionsValue<number>('subscriptionCreatedAt');\n  const expirationTime = await getOptionsValue<number>(\n    'subscriptionExpirationTime',\n  );\n\n  if (dbOptedOut != null) {\n    subscription.optedOut = dbOptedOut;\n  } else {\n    if (dbNotOptedOut == null) {\n      subscription.optedOut = false;\n    } else {\n      subscription.optedOut = !dbNotOptedOut;\n    }\n  }\n  subscription.createdAt = createdAt ?? null;\n  subscription.expirationTime = expirationTime ?? null;\n\n  return subscription;\n};\n\nexport const setSubscription = async (subscription: Subscription) => {\n  if (subscription.deviceId) {\n    await db.put('Ids', {\n      type: 'userId',\n      id: subscription.deviceId,\n    });\n  }\n\n  if (typeof subscription.subscriptionToken !== 'undefined') {\n    // Allow null subscriptions to be set\n    await db.put('Ids', {\n      type: 'registrationId',\n      id: subscription.subscriptionToken,\n    });\n  }\n\n  if (subscription.optedOut != null) {\n    // Checks if null or undefined, allows false\n    await db.put('Options', {\n      key: 'optedOut',\n      value: subscription.optedOut,\n    });\n  }\n\n  if (subscription.createdAt != null) {\n    await db.put('Options', {\n      key: 'subscriptionCreatedAt',\n      value: subscription.createdAt,\n    });\n  }\n\n  if (subscription.expirationTime != null) {\n    await db.put('Options', {\n      key: 'subscriptionExpirationTime',\n      value: subscription.expirationTime,\n    });\n  } else {\n    await db.delete('Options', 'subscriptionExpirationTime');\n  }\n};\n","import Log from '../../shared/libraries/Log';\n\nexport interface CancelableTimeoutPromise {\n  cancel: () => void;\n  promise: Promise<void>;\n}\n\nexport function cancelableTimeout(\n  callback: () => Promise<void>,\n  delayInSeconds: number,\n): CancelableTimeoutPromise {\n  const delayInMilliseconds = delayInSeconds * 1000;\n\n  let timerId: number | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  let clearTimeoutHandle = () => {};\n\n  const promise = new Promise<void>((resolve, reject) => {\n    let startedExecution = false;\n\n    timerId = self.setTimeout(async () => {\n      startedExecution = true;\n      try {\n        await callback();\n        resolve();\n      } catch (e) {\n        Log._error('Failed to execute callback', e);\n        reject();\n      }\n    }, delayInMilliseconds);\n\n    clearTimeoutHandle = () => {\n      Log._debug('Cancel called');\n      self.clearTimeout(timerId);\n      if (!startedExecution) {\n        resolve();\n      }\n    };\n  });\n\n  return {\n    promise,\n    cancel: clearTimeoutHandle,\n  };\n}\n","import { ONESIGNAL_SESSION_KEY, SessionStatus } from './constants';\nimport type { Session } from './types';\n\ntype NewSessionOptions = Partial<Session> & { appId: string };\n\nexport function initializeNewSession(options: NewSessionOptions): Session {\n  const currentTimestamp = new Date().getTime();\n  const notificationId = (options && options.notificationId) || null;\n\n  return {\n    accumulatedDuration: 0,\n    appId: options.appId,\n    lastActivatedTimestamp: currentTimestamp,\n    lastDeactivatedTimestamp: null,\n    notificationId,\n    sessionKey: ONESIGNAL_SESSION_KEY,\n    startTimestamp: currentTimestamp,\n    status: SessionStatus.Active,\n  };\n}\n","import {\n  cancelableTimeout,\n  type CancelableTimeoutPromise,\n} from '../../sw/helpers/CancelableTimeout';\nimport { sendSessionDuration, updateUserSession } from '../api/sw';\nimport { encodeHashAsUriComponent } from '../context/helpers';\nimport {\n  cleanupCurrentSession,\n  clearStore,\n  db,\n  getCurrentSession,\n} from '../database/client';\nimport { getAllNotificationClickedForOutcomes } from '../database/notifications';\nimport Log from '../libraries/Log';\nimport type { OutcomesNotificationClicked } from '../models/OutcomesNotificationEvents';\nimport Path from '../models/Path';\nimport type { OutcomesConfig } from '../outcomes/types';\nimport { SessionOrigin, SessionStatus } from '../session/constants';\nimport { initializeNewSession } from '../session/helpers';\nimport type { Session, SessionOriginValue } from '../session/types';\nimport { getConfigAttribution } from './OutcomesHelper';\nimport { getBaseUrl } from './general';\n\nexport function getServiceWorkerHref(\n  config: ServiceWorkerManagerConfig,\n  appId: string,\n  sdkVersion: string,\n): string {\n  return appendServiceWorkerParams(\n    config.workerPath.getFullPath(),\n    appId,\n    sdkVersion,\n  );\n}\n\nfunction appendServiceWorkerParams(\n  workerFullPath: string,\n  appId: string,\n  sdkVersion: string,\n): string {\n  const fullPath = new URL(workerFullPath, getBaseUrl()).href;\n  const appIdAsQueryParam = encodeHashAsUriComponent({ appId });\n  const sdkVersionAsQueryParam = encodeHashAsUriComponent({\n    sdkVersion,\n  });\n  return `${fullPath}?${appIdAsQueryParam}&${sdkVersionAsQueryParam}`;\n}\n\nexport async function upsertSession(\n  appId: string,\n  onesignalId: string,\n  subscriptionId: string,\n  sessionThresholdInSeconds: number,\n  sendOnFocusEnabled: boolean,\n  sessionOrigin: SessionOriginValue,\n  outcomesConfig: OutcomesConfig,\n): Promise<void> {\n  const existingSession = await getCurrentSession();\n\n  if (!existingSession) {\n    const session: Session = initializeNewSession({ appId });\n\n    // if there is a record about a clicked notification in our database, attribute session to it.\n    const clickedNotification: OutcomesNotificationClicked | null =\n      await getLastNotificationClickedForOutcomes(appId);\n    if (clickedNotification) {\n      session.notificationId = clickedNotification.notificationId;\n    }\n\n    await db.put('Sessions', session);\n    await sendOnSessionCallIfNotPlayerCreate(\n      appId,\n      onesignalId,\n      subscriptionId,\n      sessionOrigin,\n      session,\n    );\n    return;\n  }\n\n  if (existingSession.status === SessionStatus.Active) {\n    Log._debug('Session already active', existingSession);\n    return;\n  }\n\n  if (!existingSession.lastDeactivatedTimestamp) {\n    Log._debug('Session is in invalid state', existingSession);\n    // TODO: possibly recover by re-starting session if deviceId is present?\n    return;\n  }\n\n  const currentTimestamp = new Date().getTime();\n  const timeSinceLastDeactivatedInSeconds: number =\n    timeInSecondsBetweenTimestamps(\n      currentTimestamp,\n      existingSession.lastDeactivatedTimestamp,\n    );\n\n  if (timeSinceLastDeactivatedInSeconds <= sessionThresholdInSeconds) {\n    existingSession.status = SessionStatus.Active;\n    existingSession.lastActivatedTimestamp = currentTimestamp;\n    existingSession.lastDeactivatedTimestamp = null;\n    await db.put('Sessions', existingSession);\n    return;\n  }\n\n  // If failed to report/clean-up last time, we can attempt to try again here.\n  // TODO: Possibly check that it's not unreasonably long.\n  // TODO: Or couple with periodic ping for better results.\n  await finalizeSession(\n    appId,\n    onesignalId,\n    subscriptionId,\n    existingSession,\n    sendOnFocusEnabled,\n    outcomesConfig,\n  );\n  const session: Session = initializeNewSession({ appId });\n  await db.put('Sessions', session);\n  await sendOnSessionCallIfNotPlayerCreate(\n    appId,\n    onesignalId,\n    subscriptionId,\n    sessionOrigin,\n    session,\n  );\n}\n\nexport async function deactivateSession(\n  appId: string,\n  onesignalId: string,\n  subscriptionId: string,\n  thresholdInSeconds: number,\n  sendOnFocusEnabled: boolean,\n  outcomesConfig: OutcomesConfig,\n): Promise<CancelableTimeoutPromise | undefined> {\n  const existingSession = await getCurrentSession();\n\n  if (!existingSession) {\n    Log._debug('No active session found. Cannot deactivate.');\n    return undefined;\n  }\n\n  const finalizeSWSession = () =>\n    finalizeSession(\n      appId,\n      onesignalId,\n      subscriptionId,\n      existingSession,\n      sendOnFocusEnabled,\n      outcomesConfig,\n    );\n\n  /**\n   * For 2 subsequent deactivate requests we need to make sure there is an active finalization timeout.\n   * Timer gets cleaned up before figuring out it's activate or deactivate.\n   * No update needed for the session, early return.\n   */\n  if (existingSession.status === SessionStatus.Inactive) {\n    return cancelableTimeout(finalizeSWSession, thresholdInSeconds);\n  }\n\n  /**\n   * Can only be active or expired at this point, but more statuses may come in in the future.\n   * For anything but active, logging a warning and doing early return.\n   */\n  if (existingSession.status !== SessionStatus.Active) {\n    Log._warn(\n      `Session in invalid state ${existingSession.status}. Cannot deactivate.`,\n    );\n    return undefined;\n  }\n\n  const currentTimestamp = new Date().getTime();\n  const timeSinceLastActivatedInSeconds: number =\n    timeInSecondsBetweenTimestamps(\n      currentTimestamp,\n      existingSession.lastActivatedTimestamp,\n    );\n\n  existingSession.lastDeactivatedTimestamp = currentTimestamp;\n  existingSession.accumulatedDuration += timeSinceLastActivatedInSeconds;\n  existingSession.status = SessionStatus.Inactive;\n\n  const cancelableFinalize = cancelableTimeout(\n    finalizeSWSession,\n    thresholdInSeconds,\n  );\n\n  await db.put('Sessions', existingSession);\n\n  return cancelableFinalize;\n}\n\n/**\n * Updates session only if it isn't from the result of a user create,\n * as it already initializes it with the first session.\n */\nasync function sendOnSessionCallIfNotPlayerCreate(\n  appId: string,\n  onesignalId: string,\n  subscriptionId: string,\n  sessionOrigin: SessionOriginValue,\n  session: Session,\n) {\n  if (sessionOrigin === SessionOrigin.UserCreate) {\n    return;\n  }\n\n  db.put('Sessions', session);\n  resetSentUniqueOutcomes();\n\n  // USER MODEL TO DO: handle potential 404 - user does not exist\n  await updateUserSession(appId, onesignalId, subscriptionId);\n}\n\nasync function finalizeSession(\n  appId: string,\n  onesignalId: string,\n  subscriptionId: string,\n  session: Session,\n  sendOnFocusEnabled: boolean,\n  outcomesConfig: OutcomesConfig,\n): Promise<void> {\n  Log._debug(\n    'Finalize session',\n    `started: ${new Date(session.startTimestamp)}`,\n    `duration: ${session.accumulatedDuration}s`,\n  );\n  if (sendOnFocusEnabled) {\n    Log._debug(\n      `send on_focus reporting session duration -> ${session.accumulatedDuration}s`,\n    );\n    const attribution = await getConfigAttribution(outcomesConfig);\n    Log._debug('send on_focus with attribution', attribution);\n    await sendSessionDuration(\n      appId,\n      onesignalId,\n      subscriptionId,\n      session.accumulatedDuration,\n      attribution,\n    );\n  }\n\n  await Promise.all([\n    cleanupCurrentSession(),\n    clearStore('Outcomes.NotificationClicked'),\n  ]);\n  Log._debug(\n    'Finalize session finished',\n    `started: ${new Date(session.startTimestamp)}`,\n  );\n}\n\nconst resetSentUniqueOutcomes = async (): Promise<void> => {\n  const outcomes = await db.getAll('SentUniqueOutcome');\n  const promises = outcomes.map((o) => {\n    o.sentDuringSession = null;\n    return db.put('SentUniqueOutcome', o);\n  });\n  await Promise.all(promises);\n};\n\nconst getLastNotificationClickedForOutcomes = async (\n  appId: string,\n): Promise<OutcomesNotificationClicked | null> => {\n  let allClickedNotifications: OutcomesNotificationClicked[] = [];\n  try {\n    allClickedNotifications = await getAllNotificationClickedForOutcomes();\n  } catch (e) {\n    Log._error('Database.getLastNotificationClickedForOutcomes', e);\n  }\n  const predicate = (notification: OutcomesNotificationClicked) =>\n    notification.appId === appId;\n  return allClickedNotifications.find(predicate) || null;\n};\n\nfunction timeInSecondsBetweenTimestamps(\n  timestamp1: number,\n  timestamp2: number,\n): number {\n  if (timestamp1 <= timestamp2) {\n    return 0;\n  }\n  return Math.floor((timestamp1 - timestamp2) / 1000);\n}\n\nexport const ServiceWorkerActiveState = {\n  /**\n   * OneSignalSDKWorker.js, or the equivalent custom file name, is active.\n   */\n  OneSignalWorker: 'OneSignal Worker',\n  /**\n   * A service worker is active, but it is not OneSignalSDKWorker.js\n   * (or the equivalent custom file names as provided by user config).\n   */\n  ThirdParty: '3rd Party',\n  /**\n   * No service worker is installed.\n   */\n  None: 'None',\n} as const;\n\nexport type ServiceWorkerActiveStateValue =\n  (typeof ServiceWorkerActiveState)[keyof typeof ServiceWorkerActiveState];\n\nexport interface ServiceWorkerManagerConfig {\n  /**\n   * The path and filename of the \"main\" worker (e.g. '/OneSignalSDKWorker.js');\n   */\n  workerPath: Path;\n  /**\n   * Describes how much of the origin the service worker controls.\n   * This is currently always \"/\".\n   */\n  registrationOptions: { scope: string };\n}\n","import { sortArrayOfObjects } from '../context/helpers';\nimport { db, getCurrentSession } from '../database/client';\nimport {\n  getAllNotificationClickedForOutcomes,\n  getAllNotificationReceivedForOutcomes,\n} from '../database/notifications';\nimport Log from '../libraries/Log';\nimport type { OutcomeProps } from '../models/OutcomeProps';\nimport {\n  type OutcomeAttribution,\n  OutcomeAttributionType,\n  type SentUniqueOutcome,\n} from '../models/Outcomes';\nimport type { OutcomesNotificationReceived } from '../models/OutcomesNotificationEvents';\nimport type { OutcomesConfig } from '../outcomes/types';\nimport { awaitOneSignalInitAndSupported, logMethodCall } from '../utils/utils';\n\nconst SEND_OUTCOME = 'sendOutcome';\nconst SEND_UNIQUE_OUTCOME = 'sendUniqueOutcome';\n\nexport default class OutcomesHelper {\n  private outcomeName: string;\n  private config: OutcomesConfig;\n  private appId: string;\n  private isUnique: boolean;\n\n  /**\n   * @param  {string} appId\n   * @param  {OutcomesConfig} config - refers specifically to outcomes config\n   * @param  {boolean} isUnique\n   * @param  {string} outcomeName\n   */\n  constructor(\n    appId: string,\n    config: OutcomesConfig,\n    outcomeName: string,\n    isUnique: boolean,\n  ) {\n    this.outcomeName = outcomeName;\n    this.config = config;\n    this.appId = appId;\n    this.isUnique = isUnique;\n  }\n  /**\n   * Returns `OutcomeAttribution` object which includes\n   *    1) attribution type\n   *    2) notification ids\n   *\n   * Note: this just looks at notifications that fall within the attribution window and\n   *       does not check if they have been previously attributed (used in both sendOutcome & sendUniqueOutcome)\n   * @returns Promise\n   */\n  async getAttribution(): Promise<OutcomeAttribution> {\n    return await getConfigAttribution(this.config);\n  }\n\n  /**\n   * Performs logging of method call and returns whether Outcomes are supported\n   * @param  {boolean} isUnique\n   * @returns Promise\n   */\n  async beforeOutcomeSend(): Promise<boolean> {\n    const outcomeMethodString = this.isUnique\n      ? SEND_UNIQUE_OUTCOME\n      : SEND_OUTCOME;\n    logMethodCall(outcomeMethodString, this.outcomeName);\n\n    if (!this.config) {\n      Log._debug('Outcomes feature not supported by main application yet.');\n      return false;\n    }\n\n    if (!this.outcomeName) {\n      Log._error('Outcome name is required');\n      return false;\n    }\n\n    await awaitOneSignalInitAndSupported();\n\n    const isSubscribed =\n      await OneSignal.context._subscriptionManager.isPushNotificationsEnabled();\n    if (!isSubscribed) {\n      Log._warn('Reporting outcomes is supported only for subscribed users.');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns array of notification ids outcome is currently attributed with\n   * @param  {string} outcomeName\n   * @returns Promise\n   */\n  async getAttributedNotifsByUniqueOutcomeName(): Promise<string[]> {\n    const sentOutcomes = await db.getAll('SentUniqueOutcome');\n    return sentOutcomes\n      .filter((o) => o.outcomeName === this.outcomeName)\n      .reduce((acc: string[], curr: SentUniqueOutcome) => {\n        const notificationIds = curr.notificationIds || [];\n        return [...acc, ...notificationIds];\n      }, []);\n  }\n\n  /**\n   * Returns array of new notifications that have never been attributed to the outcome\n   * @param  {string} outcomeName\n   * @param  {string[]} notificationIds\n   */\n  async getNotifsToAttributeWithUniqueOutcome(notificationIds: string[]) {\n    const previouslyAttributedArr: string[] =\n      await this.getAttributedNotifsByUniqueOutcomeName();\n\n    return notificationIds.filter(\n      (id) => previouslyAttributedArr.indexOf(id) === -1,\n    );\n  }\n\n  shouldSendUnique(outcomeAttribution: OutcomeAttribution, notifArr: string[]) {\n    // we should only send if type is unattributed OR there are notifs to attribute\n    if (outcomeAttribution.type === OutcomeAttributionType.Unattributed) {\n      return true;\n    }\n    return notifArr.length > 0;\n  }\n\n  async saveSentUniqueOutcome(newNotificationIds: string[]): Promise<void> {\n    const outcomeName = this.outcomeName;\n    const existingSentOutcome = await db.get('SentUniqueOutcome', outcomeName);\n    const currentSession = await getCurrentSession();\n\n    const existingNotificationIds = !!existingSentOutcome\n      ? existingSentOutcome.notificationIds\n      : [];\n    const notificationIds = [...existingNotificationIds, ...newNotificationIds];\n\n    const timestamp = currentSession ? currentSession.startTimestamp : null;\n    await db.put('SentUniqueOutcome', {\n      outcomeName,\n      notificationIds,\n      sentDuringSession: timestamp,\n    });\n  }\n\n  async wasSentDuringSession() {\n    const sentOutcome = await db.get('SentUniqueOutcome', this.outcomeName);\n\n    if (!sentOutcome) {\n      return false;\n    }\n\n    const session = await getCurrentSession();\n\n    const sessionExistsAndWasPreviouslySent =\n      session && sentOutcome.sentDuringSession === session.startTimestamp;\n    const sessionWasClearedButWasPreviouslySent =\n      !session && !!sentOutcome.sentDuringSession;\n\n    return (\n      sessionExistsAndWasPreviouslySent || sessionWasClearedButWasPreviouslySent\n    );\n  }\n\n  async send(outcomeProps: OutcomeProps): Promise<void> {\n    const { type, notificationIds, weight } = outcomeProps;\n\n    switch (type) {\n      case OutcomeAttributionType.Direct:\n        if (this.isUnique) {\n          await this.saveSentUniqueOutcome(notificationIds);\n        }\n        await OneSignal.context._updateManager.sendOutcomeDirect(\n          this.appId,\n          notificationIds,\n          this.outcomeName,\n          weight,\n        );\n        return;\n      case OutcomeAttributionType.Indirect:\n        if (this.isUnique) {\n          await this.saveSentUniqueOutcome(notificationIds);\n        }\n        await OneSignal.context._updateManager.sendOutcomeInfluenced(\n          this.appId,\n          notificationIds,\n          this.outcomeName,\n          weight,\n        );\n        return;\n      case OutcomeAttributionType.Unattributed:\n        if (this.isUnique) {\n          if (await this.wasSentDuringSession()) {\n            Log._warn(\n              `(Unattributed) unique outcome was already sent during this session`,\n            );\n            return;\n          }\n          await this.saveSentUniqueOutcome([]);\n        }\n        await OneSignal.context._updateManager.sendOutcomeUnattributed(\n          this.appId,\n          this.outcomeName,\n          weight,\n        );\n        return;\n      default:\n        Log._warn(\n          'You are on a free plan. Please upgrade to use this functionality.',\n        );\n        return;\n    }\n  }\n\n  // statics\n}\n\n/**\n * Static method: returns `OutcomeAttribution` object which includes\n *    1) attribution type\n *    2) notification ids\n *\n * Note: this just looks at notifications that fall within the attribution window and\n *       does not check if they have been previously attributed (used in both sendOutcome & sendUniqueOutcome)\n * @param  {OutcomesConfig} config\n * @returns Promise\n */\nexport async function getConfigAttribution(\n  config: OutcomesConfig,\n): Promise<OutcomeAttribution> {\n  /**\n   * Flow:\n   * 1. check if the url was opened as a result of a notif;\n   * 2. if so, send an api call reporting direct notification outcome\n   *    (currently takes into account the match strategy selected in the app's settings);\n   * 3. else check all received notifs within timeframe from config;\n   * 4. send an api call reporting an influenced outcome for each matching notification\n   *    respecting the limit from config too;\n   * 5. if no influencing notification found, report unattributed outcome to the api.\n   */\n\n  /* direct notifications */\n  if (config.direct && config.direct.enabled) {\n    const clickedNotifications = await getAllNotificationClickedForOutcomes();\n    if (clickedNotifications.length > 0) {\n      return {\n        type: OutcomeAttributionType.Direct,\n        notificationIds: [clickedNotifications[0].notificationId],\n      };\n    }\n  }\n\n  /* influencing notifications */\n  if (config.indirect && config.indirect.enabled) {\n    const timeframeMs = config.indirect.influencedTimePeriodMin * 60 * 1000;\n    const beginningOfTimeframe = new Date(new Date().getTime() - timeframeMs);\n    const maxTimestamp = beginningOfTimeframe.getTime();\n\n    const allReceivedNotification =\n      await getAllNotificationReceivedForOutcomes();\n    Log._debug(\n      `\\tFound total of ${allReceivedNotification.length} received notifications`,\n    );\n\n    if (allReceivedNotification.length > 0) {\n      const max: number = config.indirect.influencedNotificationsLimit;\n      /**\n       * To handle correctly the case when user got subscribed to a new app id\n       * we check the appId on notifications to match the current app.\n       */\n\n      const allReceivedNotificationSorted = sortArrayOfObjects(\n        allReceivedNotification,\n        (notif: OutcomesNotificationReceived) => notif.timestamp,\n        true,\n        false,\n      );\n      const matchingNotificationIds = allReceivedNotificationSorted\n        .filter((notif) => notif.timestamp >= maxTimestamp)\n        .slice(0, max)\n        .map((notif) => notif.notificationId);\n      Log._debug(\n        `\\tTotal of ${matchingNotificationIds.length} received notifications are within reporting window.`,\n      );\n\n      // Deleting all unmatched received notifications\n      const notificationIdsToDelete = allReceivedNotificationSorted\n        .filter(\n          (notif) =>\n            matchingNotificationIds.indexOf(notif.notificationId) === -1,\n        )\n        .map((notif) => notif.notificationId);\n      notificationIdsToDelete.forEach((id) =>\n        db.delete('Outcomes.NotificationReceived', id),\n      );\n      Log._debug(\n        `\\t${notificationIdsToDelete.length} received notifications will be deleted.`,\n      );\n\n      if (matchingNotificationIds.length > 0) {\n        return {\n          type: OutcomeAttributionType.Indirect,\n          notificationIds: matchingNotificationIds,\n        };\n      }\n    }\n  }\n\n  /* unattributed outcome report */\n  if (config.unattributed && config.unattributed.enabled) {\n    return {\n      type: OutcomeAttributionType.Unattributed,\n      notificationIds: [],\n    };\n  }\n\n  return {\n    type: OutcomeAttributionType.NotSupported,\n    notificationIds: [],\n  };\n}\n","export const OutcomeAttributionType = {\n  Direct: 1,\n  Indirect: 2,\n  Unattributed: 3,\n  NotSupported: 4,\n} as const;\n\nexport type OutcomeAttributionTypeValue =\n  (typeof OutcomeAttributionType)[keyof typeof OutcomeAttributionType];\n\nexport interface OutcomeAttribution {\n  type: OutcomeAttributionTypeValue;\n  notificationIds: string[];\n}\n\nexport interface SentUniqueOutcome {\n  outcomeName: string;\n  notificationIds: string[];\n  sentDuringSession: number | null; // used for unattributed\n}\n","import Log from '../libraries/Log';\nimport type { OutcomeRequestData } from '../outcomes/types';\nimport * as OneSignalApiBase from './base';\n\nexport async function sendOutcome(data: OutcomeRequestData): Promise<void> {\n  Log._info('Outcome payload:', data);\n  try {\n    await OneSignalApiBase.post('outcomes/measure', data);\n  } catch (e) {\n    Log._error('sendOutcome', e);\n  }\n}\n","export const WorkerMessengerCommand = {\n  WorkerVersion: 'GetWorkerVersion',\n  Subscribe: 'Subscribe',\n  SubscribeNew: 'SubscribeNew',\n  NotificationWillDisplay: 'notification.willDisplay',\n  NotificationClicked: 'notification.clicked',\n  NotificationDismissed: 'notification.dismissed',\n  SessionUpsert: 'os.session.upsert',\n  SessionDeactivate: 'os.session.deactivate',\n  AreYouVisible: 'os.page_focused_request',\n  AreYouVisibleResponse: 'os.page_focused_response',\n  SetLogging: 'os.set_sw_logging',\n} as const;\n","import type { ContextInterface, ContextSWInterface } from '../../context/types';\nimport type {\n  WorkerMessengerCommandValue,\n  WorkerMessengerReplyBufferRecord,\n} from './types';\n\nexport class WorkerMessengerReplyBuffer {\n  private _replies: {\n    [index: string]: WorkerMessengerReplyBufferRecord[] | null;\n  };\n\n  constructor() {\n    this._replies = {};\n  }\n\n  public _addListener(\n    command: WorkerMessengerCommandValue,\n    callback: (param: unknown) => void,\n    onceListenerOnly: boolean,\n  ) {\n    const record: WorkerMessengerReplyBufferRecord = {\n      callback,\n      onceListenerOnly,\n    };\n\n    const replies = this._replies[command.toString()];\n    if (replies) replies.push(record);\n    else this._replies[command.toString()] = [record];\n  }\n\n  public _findListenersForMessage(\n    command: WorkerMessengerCommandValue,\n  ): WorkerMessengerReplyBufferRecord[] {\n    return this._replies[command.toString()] || [];\n  }\n\n  public _deleteListenerRecords(command: WorkerMessengerCommandValue) {\n    this._replies[command.toString()] = null;\n  }\n\n  public _deleteAllListenerRecords() {\n    this._replies = {};\n  }\n\n  public _deleteListenerRecord(\n    command: WorkerMessengerCommandValue,\n    targetRecord: object,\n  ) {\n    const listenersForCommand = this._replies[command.toString()];\n    if (listenersForCommand == null) return;\n\n    for (\n      let listenerRecordIndex = listenersForCommand.length - 1;\n      listenerRecordIndex >= 0;\n      listenerRecordIndex--\n    ) {\n      const listenerRecord = listenersForCommand[listenerRecordIndex];\n      if (listenerRecord === targetRecord) {\n        listenersForCommand.splice(listenerRecordIndex, 1);\n      }\n    }\n  }\n}\n\n/**\n * A Promise-based PostMessage helper to ease back-and-forth replies between\n * service workers and window frames.\n */\nexport class WorkerMessengerBase<\n  C extends ContextInterface | ContextSWInterface =\n    | ContextInterface\n    | ContextSWInterface,\n> {\n  protected _context?: C;\n  protected _replies: WorkerMessengerReplyBuffer;\n\n  constructor(\n    context?: C,\n    replies: WorkerMessengerReplyBuffer = new WorkerMessengerReplyBuffer(),\n  ) {\n    this._context = context;\n    this._replies = replies;\n  }\n\n  /*\n    Subscribes a callback to be notified every time a service worker sends a\n    message to the window frame with the specific command.\n   */\n  _on(\n    command: WorkerMessengerCommandValue,\n    callback: (WorkerMessengerPayload: any) => void,\n  ): void {\n    this._replies._addListener(command, callback, false);\n  }\n\n  /*\n  Subscribes a callback to be notified the next time a service worker sends a\n  message to the window frame with the specific command.\n\n  The callback is executed once at most.\n  */\n  _once(\n    command: WorkerMessengerCommandValue,\n    callback: (WorkerMessengerPayload: any) => void,\n  ): void {\n    this._replies._addListener(command, callback, true);\n  }\n\n  /**\n    Unsubscribe a callback from being notified about service worker messages\n    with the specified command.\n   */\n  _off(command?: WorkerMessengerCommandValue): void {\n    if (command) {\n      this._replies._deleteListenerRecords(command);\n    } else {\n      this._replies._deleteAllListenerRecords();\n    }\n  }\n}\n","import { EmptyArgumentError } from 'src/shared/errors/common';\nimport type ContextSW from 'src/shared/models/ContextSW';\nimport Log from '../Log';\nimport { WorkerMessengerBase } from './base';\nimport type {\n  WorkerMessengerCommandValue,\n  WorkerMessengerMessage,\n  WorkerMessengerPayload,\n} from './types';\n\ndeclare let self: ServiceWorkerGlobalScope;\n\nexport class WorkerMessengerSW extends WorkerMessengerBase<ContextSW> {\n  /**\n   * Due to https://github.com/w3c/ServiceWorker/issues/1156, listen() must\n   * synchronously add self.addEventListener('message') if we are running in the\n   * service worker.\n   */\n  public async _listen() {\n    self.addEventListener(\n      'message',\n      this._onWorkerMessageReceivedFromPage.bind(this),\n    );\n    Log._debug(\n      '[Worker Messenger] Service worker is now listening for messages.',\n    );\n  }\n\n  _onWorkerMessageReceivedFromPage(event: ExtendableMessageEvent) {\n    const data: WorkerMessengerMessage = event.data;\n\n    /* If this message doesn't contain our expected fields, discard the message */\n    /* The payload may be null.\n     */\n    if (!data || !data.command) {\n      return;\n    }\n\n    const listenerRecords = this._replies._findListenersForMessage(\n      data.command,\n    );\n    const listenersToRemove = [];\n    const listenersToCall = [];\n\n    Log._debug(\n      `[Worker Messenger] Service worker received message:`,\n      event.data,\n    );\n\n    for (const listenerRecord of listenerRecords) {\n      if (listenerRecord.onceListenerOnly) {\n        listenersToRemove.push(listenerRecord);\n      }\n      listenersToCall.push(listenerRecord);\n    }\n    for (let i = listenersToRemove.length - 1; i >= 0; i--) {\n      const listenerRecord = listenersToRemove[i];\n      this._replies._deleteListenerRecord(data.command, listenerRecord);\n    }\n    for (const listenerRecord of listenersToCall) {\n      listenerRecord.callback.apply(null, [data.payload]);\n    }\n  }\n\n  /**\n   * Broadcasts a message from a service worker to all clients, including uncontrolled clients.\n   */\n  async _broadcast(\n    command: WorkerMessengerCommandValue,\n    payload: WorkerMessengerPayload,\n  ) {\n    const clients = await self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true,\n    });\n    for (const client of clients) {\n      Log._debug(\n        `[Worker Messenger] [SW -> Page] Broadcasting '${command.toString()}' to window client ${\n          client.url\n        }.`,\n      );\n      client.postMessage({\n        command: command,\n        payload: payload,\n      });\n    }\n  }\n\n  /**\n   * Sends a postMessage() to the supplied windowClient\n   */\n  async _unicast(\n    command: WorkerMessengerCommandValue,\n    payload?: WorkerMessengerPayload,\n    windowClient?: Client,\n  ) {\n    if (!windowClient) {\n      throw EmptyArgumentError('windowClient');\n    }\n\n    Log._debug(\n      `[Worker Messenger] [SW -> Page] Unicasting '${command.toString()}' to window client ${\n        windowClient.url\n      }.`,\n    );\n    windowClient.postMessage({\n      command: command,\n      payload: payload,\n    } as any);\n  }\n}\n","import type { Serializable } from '../../page/models/Serializable';\n\nexport class RawPushSubscription implements Serializable {\n  /**\n   * The GCM/FCM registration token, along with the full URL. Not used for Safari.\n   */\n  w3cEndpoint: URL | undefined;\n  w3cP256dh: string | undefined;\n  w3cAuth: string | undefined;\n  /**\n   * A Safari-only push subscription device token. Not used for Chrome/Firefox.\n   */\n  safariDeviceToken: string | undefined;\n\n  /**\n   * Given a native W3C browser push subscription, takes the endpoint, p256dh,\n   * and auth.\n   *\n   * @param pushSubscription A native browser W3C push subscription.\n   */\n  public static _setFromW3cSubscription(\n    pushSubscription: PushSubscription,\n  ): RawPushSubscription {\n    const rawPushSubscription = new RawPushSubscription();\n\n    if (pushSubscription) {\n      rawPushSubscription.w3cEndpoint = new URL(pushSubscription.endpoint);\n\n      // Retrieve p256dh and auth for encrypted web push protocol\n      if (pushSubscription.getKey) {\n        // p256dh and auth are both ArrayBuffer\n        let p256dh = null;\n        try {\n          p256dh = pushSubscription.getKey('p256dh');\n        } catch (e) {\n          // User is most likely running < Chrome < 50\n        }\n        let auth = null;\n        try {\n          auth = pushSubscription.getKey('auth');\n        } catch (e) {\n          // User is most likely running < Firefox 45\n        }\n\n        if (p256dh) {\n          // Base64 encode the ArrayBuffer (not URL-Safe, using standard Base64)\n          const p256dh_base64encoded = btoa(\n            String.fromCharCode(...new Uint8Array(p256dh)),\n          );\n          rawPushSubscription.w3cP256dh = p256dh_base64encoded;\n        }\n        if (auth) {\n          // Base64 encode the ArrayBuffer (not URL-Safe, using standard Base64)\n          const auth_base64encoded = btoa(\n            String.fromCharCode(...new Uint8Array(auth)),\n          );\n          rawPushSubscription.w3cAuth = auth_base64encoded;\n        }\n      }\n    }\n\n    return rawPushSubscription;\n  }\n\n  /**\n   * Given a native browser Safari push subscription, sets the device token\n   * property.\n   *\n   * @param safariDeviceToken A native browser Safari push subscription.\n   */\n  public _setFromSafariSubscription(safariDeviceToken?: string | null) {\n    if (!safariDeviceToken) {\n      return;\n    }\n    this.safariDeviceToken = safariDeviceToken;\n  }\n\n  public _serialize() {\n    const serializedBundle = {\n      /* Old Parameters */\n      w3cEndpoint: this.w3cEndpoint ? this.w3cEndpoint.toString() : null,\n      w3cP256dh: this.w3cP256dh,\n      w3cAuth: this.w3cAuth,\n      safariDeviceToken: this.safariDeviceToken,\n    };\n\n    return serializedBundle;\n  }\n\n  // TODO: had a hard to debug bug here due to \"any\" type bypassing typescript validation.\n  // Check the usage and maybe change with strict type\n  public static _deserialize(bundle: any): RawPushSubscription {\n    const subscription = new RawPushSubscription();\n    if (!bundle) {\n      return subscription;\n    }\n    try {\n      subscription.w3cEndpoint = new URL(bundle.w3cEndpoint);\n    } catch (e) {\n      // w3cEndpoint will be null for Safari\n    }\n    subscription.w3cP256dh = bundle.w3cP256dh;\n    subscription.w3cAuth = bundle.w3cAuth;\n    subscription.safariDeviceToken = bundle.safariDeviceToken;\n    return subscription;\n  }\n}\n","import {\n  getSubscription,\n  setSubscription,\n} from 'src/shared/database/subscription';\nimport type { NotificationTypeValue } from 'src/shared/subscriptions/types';\nimport type { ContextInterface, ContextSWInterface } from '../../context/types';\nimport { useSafariLegacyPush } from '../../environment/detect';\nimport Log from '../../libraries/Log';\nimport { RawPushSubscription } from '../../models/RawPushSubscription';\nimport type { Subscription } from '../../models/Subscription';\nimport {\n  SubscriptionStrategyKind,\n  type SubscriptionStrategyKindValue,\n} from '../../models/SubscriptionStrategyKind';\nimport OneSignalEvent from '../../services/OneSignalEvent';\nimport { SessionOrigin } from '../../session/constants';\nimport { Browser } from '../../useragent/constants';\nimport { getBrowserName } from '../../useragent/detect';\nimport { base64ToUint8Array } from '../../utils/Encoding';\nimport { IS_SERVICE_WORKER } from '../../utils/EnvVariables';\nimport { DEFAULT_DEVICE_ID } from './constants';\n\nexport interface SubscriptionManagerConfig {\n  safariWebId?: string;\n  appId: string;\n  /**\n   * The VAPID public key to use for Chrome-like browsers, including Opera and Yandex browser.\n   */\n  vapidPublicKey?: string;\n  /**\n   * A globally shared VAPID public key to use for the Firefox browser, which does not use\n   * VAPID for authentication but for application identification and uses a single\n   */\n  onesignalVapidPublicKey?: string;\n}\n\nexport class SubscriptionManagerBase<\n  C extends ContextSWInterface | ContextInterface,\n> {\n  protected _context: C;\n  protected _config: SubscriptionManagerConfig;\n\n  constructor(context: C, config: SubscriptionManagerConfig) {\n    this._context = context;\n    this._config = config;\n  }\n\n  /**\n   * Creates a device record from the provided raw push subscription and forwards this device record\n   * to OneSignal to create or update the device ID.\n   *\n   * @param rawPushSubscription The raw push subscription obtained from calling subscribe(). This\n   * can be null, in which case OneSignal's device record is set to unsubscribed.\n   *\n   * @param subscriptionState TODO: This is no longer used here and needs some refactoring to\n   * put this back into place.\n   * Describes whether the device record is subscribed, unsubscribed, or in\n   * another state. By default, this is set from the availability of rawPushSubscription (exists:\n   * Subscribed, null: Unsubscribed). Other use cases may result in creation of a device record that\n   * warrants a special subscription state. For example, a device ID can be retrieved by providing\n   * an identifier, and a new device record will be created if the identifier didn't exist. These\n   * records are marked with a special subscription state for tracking purposes.\n   */\n  public async _registerSubscription(\n    pushSubscription: RawPushSubscription | undefined,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _subscriptionState?: NotificationTypeValue | null,\n  ): Promise<Subscription> {\n    /*\n      This may be called after the RawPushSubscription has been serialized across a postMessage\n      frame. This means it will only have object properties and none of the functions. We have to\n      recreate the RawPushSubscription.\n\n      Keep in mind pushSubscription can be null in cases where resubscription isn't possible\n      (blocked permission).\n    */\n    if (pushSubscription) {\n      pushSubscription = RawPushSubscription._deserialize(pushSubscription);\n    }\n\n    if (await this._isAlreadyRegisteredWithOneSignal()) {\n      if (!IS_SERVICE_WORKER && '_updateManager' in this._context) {\n        await this._context._updateManager.sendPushDeviceRecordUpdate();\n      }\n\n      // NOTE: We only have sessionManager in the page context, should sw upsert do anything?\n    } else if (!IS_SERVICE_WORKER && '_sessionManager' in this._context) {\n      this._context._sessionManager.upsertSession(SessionOrigin.UserCreate);\n    }\n\n    const subscription = await getSubscription();\n    // User Model: TO DO: Remove this once we have a better way to determine if the user is subscribed\n    subscription.deviceId = DEFAULT_DEVICE_ID;\n    subscription.optedOut = false;\n    if (pushSubscription) {\n      if (useSafariLegacyPush()) {\n        subscription.subscriptionToken = pushSubscription.safariDeviceToken;\n      } else {\n        subscription.subscriptionToken = pushSubscription.w3cEndpoint\n          ? pushSubscription.w3cEndpoint.toString()\n          : null;\n      }\n    } else {\n      subscription.subscriptionToken = null;\n    }\n    await setSubscription(subscription);\n\n    if (!IS_SERVICE_WORKER) {\n      OneSignalEvent.trigger(OneSignal.EVENTS.REGISTERED);\n    }\n\n    if (typeof OneSignal !== 'undefined') {\n      OneSignal._sessionInitAlreadyRunning = false;\n    }\n    return subscription;\n  }\n\n  public async _isAlreadyRegisteredWithOneSignal(): Promise<boolean> {\n    const { deviceId } = await getSubscription();\n    return !!deviceId;\n  }\n\n  /**\n   * Uses the browser's PushManager interface to actually subscribe for a web push subscription.\n   *\n   * @param pushManager An instance of the browser's push manager, either from the page or from the\n   * service worker.\n   *\n   * @param subscriptionStrategy Given an existing push subscription, describes whether the existing\n   * push subscription is resubscribed as-is leaving it unchanged, or unsubscribed to make room for\n   * a new push subscription.\n   */\n  public async _subscribeWithVapidKey(\n    pushManager: PushManager,\n    subscriptionStrategy: SubscriptionStrategyKindValue,\n  ): Promise<RawPushSubscription> {\n    /*\n      Always try subscribing using VAPID by providing an applicationServerKey, except for cases\n      where the user is already subscribed, handled below.\n     */\n\n    const existingPushSubscription = await pushManager.getSubscription();\n\n    /* Depending on the subscription strategy, handle existing subscription in various ways */\n    switch (subscriptionStrategy) {\n      case SubscriptionStrategyKind.ResubscribeExisting:\n        if (!existingPushSubscription) break;\n\n        if (existingPushSubscription.options) {\n          Log._debug(\n            \"[Subscription Manager] An existing push subscription exists and it's options is not null.\",\n          );\n        } else {\n          Log._debug(\n            '[Subscription Manager] An existing push subscription exists and options is null. ' +\n              'Unsubscribing from push first now.',\n          );\n          /*\n            NOTE: Only applies to rare edge case of migrating from senderId to a VAPID subscription\n            There isn't a great solution if PushSubscriptionOptions (supported on Chrome 54+) isn't\n            supported.\n\n            We want to subscribe the user, but we don't know whether the user was subscribed via\n            GCM's manifest.json or FCM's VAPID.\n\n            This bug (https://bugs.chromium.org/p/chromium/issues/detail?id=692577) shows that a\n            mismatched sender ID error is possible if you subscribe via FCM's VAPID while the user\n            was originally subscribed via GCM's manifest.json (fails silently).\n\n            Because of this, we should unsubscribe the user from push first and then resubscribe\n            them.\n          */\n\n          /* We're unsubscribing, so we want to store the created at timestamp */\n          await SubscriptionManagerBase._doPushUnsubscribe(\n            existingPushSubscription,\n          );\n        }\n        break;\n      case SubscriptionStrategyKind.SubscribeNew:\n        /* Since we want a new subscription every time with this strategy, just unsubscribe. */\n        if (existingPushSubscription) {\n          await SubscriptionManagerBase._doPushUnsubscribe(\n            existingPushSubscription,\n          );\n        }\n        break;\n    }\n\n    // Actually subscribe the user to push\n    const [newPushSubscription, isNewSubscription] =\n      await SubscriptionManagerBase._doPushSubscribe(\n        pushManager,\n        this._getVapidKeyForBrowser(),\n      );\n\n    // Update saved create and expired times\n    await SubscriptionManagerBase._updateSubscriptionTime(\n      isNewSubscription,\n      newPushSubscription.expirationTime,\n    );\n\n    // Create our own custom object from the browser's native PushSubscription object\n    const pushSubscriptionDetails =\n      RawPushSubscription._setFromW3cSubscription(newPushSubscription);\n    return pushSubscriptionDetails;\n  }\n\n  /**\n   * Returns the correct VAPID key to use for subscription based on the browser type.\n   *\n   * If the VAPID key isn't present, undefined is returned instead of null.\n   */\n  public _getVapidKeyForBrowser(): ArrayBuffer | undefined {\n    // Specifically return undefined instead of null if the key isn't available\n    let key = undefined;\n\n    if (getBrowserName() === Browser.Firefox) {\n      /*\n        Firefox uses VAPID for application identification instead of\n        authentication, and so all apps share an identification key.\n       */\n      key = this._config.onesignalVapidPublicKey;\n    } else {\n      /*\n        Chrome and Chrome-like browsers including Opera and Yandex use VAPID for\n        authentication, and so each app uses a uniquely generated key.\n       */\n      key = this._config.vapidPublicKey;\n    }\n\n    if (key) {\n      return base64ToUint8Array(key).buffer as ArrayBuffer;\n    } else {\n      return undefined;\n    }\n  }\n\n  private static async _updateSubscriptionTime(\n    updateCreatedAt: boolean,\n    expirationTime: number | null,\n  ): Promise<void> {\n    const bundle = await getSubscription();\n    if (updateCreatedAt) {\n      bundle.createdAt = new Date().getTime();\n    }\n    bundle.expirationTime = expirationTime;\n    await setSubscription(bundle);\n  }\n\n  // Subscribes the ServiceWorker for a pushToken.\n  // If there is an error doing so unsubscribe from existing and try again\n  //    - This handles subscribing to new server VAPID key if it has changed.\n  // return type - [PushSubscription, createdNewPushSubscription(boolean)]\n  private static async _doPushSubscribe(\n    pushManager: PushManager,\n    applicationServerKey: ArrayBuffer | undefined,\n  ): Promise<[PushSubscription, boolean]> {\n    if (!applicationServerKey) {\n      throw new Error(\n        \"Missing required 'applicationServerKey' to subscribe for push notifications!\",\n      );\n    }\n\n    const subscriptionOptions: PushSubscriptionOptionsInit = {\n      userVisibleOnly: true,\n      applicationServerKey: applicationServerKey,\n    };\n    Log._debug(\n      '[Subscription Manager] Subscribing to web push with these options:',\n      subscriptionOptions,\n    );\n    try {\n      const existingSubscription = await pushManager.getSubscription();\n      return [\n        await pushManager.subscribe(subscriptionOptions),\n        !existingSubscription,\n      ];\n    } catch (e) {\n      if (e instanceof Error) {\n        // This exception is thrown if the key for the existing applicationServerKey is different,\n        //    so we must unregister first.\n        // In Chrome, e.message contains will be the following in this case for reference;\n        // Registration failed - A subscription with a different applicationServerKey (or gcm_sender_id) already exists;\n        //    to change the applicationServerKey, unsubscribe then resubscribe.\n        Log._warn(\n          \"[Subscription Manager] Couldn't re-subscribe due to applicationServerKey changing, \" +\n            'unsubscribe and attempting to subscribe with new key.',\n          e,\n        );\n        const subscription = await pushManager.getSubscription();\n        if (subscription) {\n          await SubscriptionManagerBase._doPushUnsubscribe(subscription);\n        }\n        return [await pushManager.subscribe(subscriptionOptions), true];\n      } else throw e; // If some other error, bubble the exception up\n    }\n  }\n\n  private static async _doPushUnsubscribe(\n    pushSubscription: PushSubscription,\n  ): Promise<boolean> {\n    Log._debug(\n      '[Subscription Manager] Unsubscribing existing push subscription.',\n    );\n    const result = await pushSubscription.unsubscribe();\n    Log._debug(\n      `[Subscription Manager] Unsubscribing existing push subscription result: ${result}`,\n    );\n    return result;\n  }\n}\n","export const DEFAULT_DEVICE_ID = '99999999-9999-9999-9999-999999999999';\n","/**\n * When subscribing for a web push subscription, describes whether an existing subscription is first\n * unsubscribed or is left intact.\n */\nexport const SubscriptionStrategyKind = {\n  /**\n   * Creates a new push subscription or resubscribes an existing push subscription.\n   *\n   * A new push subscription is created if:\n   *   - No existing push subscription exists\n   *   - An existing push subscription exists, but the existing subscription's\n   *     PushSubscriptionOptions is null\n   *\n   * If an existing push subscription's PushSubscriptionOptions is null, possibly due to browser\n   * profile database corruption or an older or non-standard browser that doesn't support\n   * PushSubscriptionOptions, then the entire subscription is first unsubscribed before\n   * resubscribing.\n   *\n   * An existing push subscription is resubscribed (unchanged) if its PushSubscriptionOptions is\n   * present.\n   *\n   * Given an existing legacy GCM subscription, this strategy does not attempt to migrate the\n   * subscription to VAPID. Legacy GCM subscriptions have a PushSubscriptionOptions if subscribed in\n   * a supporting browser which can be used for resubscribing (i.e. leaving the subscription\n   * unchanged still as legacy GCM). Migrating the subscription to VAPID would require first\n   * unsubscribing, which this strategy does not attempt.\n   */\n  ResubscribeExisting: 0,\n  /**\n   * Unsubscribes an existing push subscription if one exists, and creates a new push subscription\n   * with a new endpoint and crypto keys.\n   *\n   * This strategy will always unsubscribe an existing push subscription if one is present. This\n   * strategy is used to \"refresh\" Microsoft Edge's expiring push subscriptions by obtaining a new\n   * subscription with a newly long duration expiration time.\n   */\n  SubscribeNew: 1,\n} as const;\n\nexport type SubscriptionStrategyKindValue =\n  (typeof SubscriptionStrategyKind)[keyof typeof SubscriptionStrategyKind];\n","import { PermissionBlockedError } from 'src/shared/errors/common';\nimport type { RawPushSubscription } from 'src/shared/models/RawPushSubscription';\nimport type { SubscriptionStrategyKindValue } from 'src/shared/models/SubscriptionStrategyKind';\nimport { Browser } from 'src/shared/useragent/constants';\nimport { getBrowserName } from 'src/shared/useragent/detect';\nimport type { ContextSWInterface } from '../../context/types';\nimport { SubscriptionManagerBase } from './base';\n\ndeclare let self: ServiceWorkerGlobalScope;\n\nexport class SubscriptionManagerSW extends SubscriptionManagerBase<ContextSWInterface> {\n  /**\n   * Subscribes for a web push subscription.\n   *\n   * This method can be called from the page context or a webpage a service worker context\n   * and will select the correct method.\n   */\n  public async _subscribe(\n    subscriptionStrategy: SubscriptionStrategyKindValue,\n  ): Promise<RawPushSubscription> {\n    return await this._subscribeFcmFromWorker(subscriptionStrategy);\n  }\n\n  public async _subscribeFcmFromWorker(\n    subscriptionStrategy: SubscriptionStrategyKindValue,\n  ): Promise<RawPushSubscription> {\n    /*\n        We're running inside of the service worker.\n  \n        Check to make sure our registration is activated, otherwise we can't\n        subscribe for push.\n  \n        HACK: Firefox doesn't set self.registration.active in the service worker\n        context. From a non-service worker context, like\n        navigator.serviceWorker.getRegistration().active, the property actually is\n        set, but it's just not set within the service worker context.\n  \n        Because of this, we're not able to check for this property on Firefox.\n       */\n\n    const swRegistration = self.registration;\n\n    if (!swRegistration.active && getBrowserName() !== Browser.Firefox) {\n      throw new Error('SW not activated');\n      /*\n          Or should we wait for the service worker to be ready?\n  \n          await new Promise(resolve => self.onactivate = resolve);\n         */\n    }\n\n    /*\n        Check to make sure push permissions have been granted.\n       */\n    const pushPermission = await swRegistration.pushManager.permissionState({\n      userVisibleOnly: true,\n    });\n    if (pushPermission === 'denied') {\n      throw PermissionBlockedError;\n    } else if (pushPermission === 'prompt') {\n      throw new Error('Permission not granted');\n    }\n\n    return await this._subscribeWithVapidKey(\n      swRegistration.pushManager,\n      subscriptionStrategy,\n    );\n  }\n}\n","import type { AppConfig } from '../config/types';\nimport type { ContextSWInterface } from '../context/types';\nimport { getSubscriptionManagerSW } from '../helpers/context';\nimport { WorkerMessengerSW } from '../libraries/workerMessenger/sw';\nimport { SubscriptionManagerSW } from '../managers/subscription/sw';\n\nexport default class ContextSW implements ContextSWInterface {\n  public _appConfig: AppConfig;\n  public _subscriptionManager: SubscriptionManagerSW;\n  public _workerMessenger: WorkerMessengerSW;\n\n  constructor(appConfig: AppConfig) {\n    this._appConfig = appConfig;\n    this._subscriptionManager = getSubscriptionManagerSW(this);\n    this._workerMessenger = new WorkerMessengerSW(this);\n  }\n}\n","import type { AppConfig } from '../config/types';\nimport {\n  DEFAULT_SERVICE_WORKER_OPTIONS,\n  DEFAULT_SERVICE_WORKER_PATH,\n} from '../context/constants';\nimport type { ContextInterface, ContextSWInterface } from '../context/types';\nimport { ServiceWorkerManager } from '../managers/ServiceWorkerManager';\nimport type { SubscriptionManagerConfig } from '../managers/subscription/base';\nimport { SubscriptionManagerPage } from '../managers/subscription/page';\nimport { SubscriptionManagerSW } from '../managers/subscription/sw';\nimport Path from '../models/Path';\n\nexport function getServiceWorkerManager(\n  context: ContextInterface,\n): ServiceWorkerManager {\n  const config: AppConfig = context._appConfig;\n\n  const serviceWorkerManagerConfig = {\n    workerPath: new Path(DEFAULT_SERVICE_WORKER_PATH),\n    registrationOptions: DEFAULT_SERVICE_WORKER_OPTIONS,\n  };\n\n  if (config.userConfig) {\n    if (config.userConfig.path) {\n      serviceWorkerManagerConfig.workerPath = new Path(\n        `${config.userConfig.path}${config.userConfig.serviceWorkerPath}`,\n      );\n    }\n    if (config.userConfig.serviceWorkerParam) {\n      serviceWorkerManagerConfig.registrationOptions =\n        config.userConfig.serviceWorkerParam;\n    }\n  }\n  return new ServiceWorkerManager(context, serviceWorkerManagerConfig);\n}\n\nfunction createSubscriptionManagerConfig(\n  config: AppConfig,\n): SubscriptionManagerConfig {\n  return {\n    safariWebId: config.safariWebId,\n    appId: config.appId,\n    vapidPublicKey: config.vapidPublicKey,\n    onesignalVapidPublicKey: config.onesignalVapidPublicKey,\n  };\n}\n\nexport function getSubscriptionManagerPage(\n  context: ContextInterface,\n): SubscriptionManagerPage {\n  return new SubscriptionManagerPage(\n    context,\n    createSubscriptionManagerConfig(context._appConfig),\n  );\n}\n\nexport function getSubscriptionManagerSW(\n  context: ContextSWInterface,\n): SubscriptionManagerSW {\n  return new SubscriptionManagerSW(\n    context,\n    createSubscriptionManagerConfig(context._appConfig),\n  );\n}\n","import type {\n  IOSNotification,\n  IOSNotificationActionButton,\n  NotificationAction,\n} from 'src/shared/notifications/types';\nimport type {\n  OSMinifiedButtonsPayload,\n  OSMinifiedNotificationPayload,\n} from '../serviceWorker/types';\n\nexport function toOSNotification(\n  payload: OSMinifiedNotificationPayload,\n): IOSNotification {\n  return {\n    notificationId: payload.custom.i,\n    title: payload.title,\n    body: payload.alert,\n    additionalData: payload.custom.a,\n    launchURL: payload.custom.u,\n    confirmDelivery: payload.custom.rr === 'y',\n    icon: payload.icon,\n    image: payload.image,\n    actionButtons: convertButtons(payload.o),\n    topic: payload.tag,\n    badgeIcon: payload.badge,\n  };\n}\n\nfunction convertButtons(\n  payloadButtons?: OSMinifiedButtonsPayload[],\n): IOSNotificationActionButton[] | undefined {\n  return payloadButtons?.map(\n    (button): IOSNotificationActionButton => ({\n      actionId: button.i,\n      text: button.n,\n      icon: button.p,\n      launchURL: button.u,\n    }),\n  );\n}\n\nexport function isValidPayload(payload: any): boolean {\n  return typeof payload?.custom?.i === 'string';\n}\n\nexport function toNativeNotificationAction(\n  actionPayload?: IOSNotificationActionButton[],\n): NotificationAction[] | undefined {\n  return actionPayload?.map(\n    (payload): NotificationAction => ({\n      action: payload.actionId,\n      title: payload.text,\n      icon: payload.icon,\n      // launchURL not a native browser feature.\n      // When clicked, we get the action to map it back to the specific\n      // IOSNotificationActionButton\n    }),\n  );\n}\n","import { getOptionsValue } from 'src/shared/database/client';\nimport type { OptionKey } from 'src/shared/database/types';\nimport Log from 'src/shared/libraries/Log';\nimport type { IOSWebhookEventPayload } from '../serviceWorker/types';\n\nexport class OSWebhookSender {\n  async send(payload: IOSWebhookEventPayload): Promise<void> {\n    const webhookTargetUrl = await getOptionsValue<string>(\n      `webhooks.${payload.event}` as OptionKey,\n    );\n    if (!webhookTargetUrl) return;\n\n    const isServerCorsEnabled = await getOptionsValue<boolean>('webhooks.cors');\n\n    const fetchOptions: RequestInit = {\n      method: 'post',\n      mode: 'no-cors',\n      body: JSON.stringify(payload),\n    };\n\n    if (isServerCorsEnabled) {\n      fetchOptions.mode = 'cors';\n      fetchOptions.headers = {\n        'X-OneSignal-Event': payload.event,\n        'Content-Type': 'application/json',\n      };\n    }\n    Log._debug(\n      `Executing ${payload.event} webhook ${\n        isServerCorsEnabled ? 'with' : 'without'\n      } CORS POST ${webhookTargetUrl}`,\n      payload,\n    );\n    await fetch(webhookTargetUrl, fetchOptions);\n    return;\n  }\n}\n","import type {\n  IOSNotification,\n  NotificationClickEvent,\n} from 'src/shared/notifications/types';\nimport { OSWebhookSender } from './../OSWebhookSender';\n\nexport class OSWebhookNotificationEventSender {\n  private readonly sender: OSWebhookSender;\n\n  constructor(sender: OSWebhookSender = new OSWebhookSender()) {\n    this.sender = sender;\n  }\n\n  async click(\n    event: NotificationClickEvent,\n    subscriptionId: string | undefined,\n  ): Promise<void> {\n    const notification = event.notification;\n    return await this.sender.send({\n      event: 'notification.clicked',\n      notificationId: notification.notificationId,\n      heading: notification.title,\n      content: notification.body,\n      additionalData: notification.additionalData,\n      actionId: event.result.actionId,\n      url: event.result.url,\n      subscriptionId,\n    });\n  }\n\n  async willDisplay(\n    notification: IOSNotification,\n    subscriptionId: string | undefined,\n  ): Promise<void> {\n    return await this.sender.send({\n      event: 'notification.willDisplay',\n      notificationId: notification.notificationId,\n      heading: notification.title,\n      content: notification.body,\n      additionalData: notification.additionalData,\n      url: notification.launchURL,\n      subscriptionId,\n    });\n  }\n\n  async dismiss(\n    notification: IOSNotification,\n    subscriptionId: string | undefined,\n  ): Promise<void> {\n    return await this.sender.send({\n      event: 'notification.dismissed',\n      notificationId: notification.notificationId,\n      heading: notification.title,\n      content: notification.body,\n      additionalData: notification.additionalData,\n      url: notification.launchURL,\n      subscriptionId,\n    });\n  }\n}\n","import * as OneSignalApiBase from 'src/shared/api/base';\nimport {\n  downloadSWServerAppConfig,\n  getUserIdFromSubscriptionIdentifier,\n} from 'src/shared/api/sw';\nimport { getServerAppConfig } from 'src/shared/config/app';\nimport type { AppConfig } from 'src/shared/config/types';\nimport { containsMatch } from 'src/shared/context/helpers';\nimport {\n  db,\n  getCurrentSession,\n  getOptionsValue,\n} from 'src/shared/database/client';\nimport { getAppState, getDBAppConfig } from 'src/shared/database/config';\nimport {\n  putNotificationClickedForOutcomes,\n  putNotificationReceivedForOutcomes,\n} from 'src/shared/database/notifications';\nimport {\n  getSubscription,\n  setSubscription,\n} from 'src/shared/database/subscription';\nimport { getDeviceType } from 'src/shared/environment/detect';\nimport { delay } from 'src/shared/helpers/general';\nimport {\n  deactivateSession,\n  upsertSession,\n} from 'src/shared/helpers/service-worker';\nimport Log from 'src/shared/libraries/Log';\nimport { WorkerMessengerCommand } from 'src/shared/libraries/workerMessenger/constants';\nimport { WorkerMessengerSW } from 'src/shared/libraries/workerMessenger/sw';\nimport type { WorkerMessengerMessage } from 'src/shared/libraries/workerMessenger/types';\nimport ContextSW from 'src/shared/models/ContextSW';\nimport type { DeliveryPlatformKindValue } from 'src/shared/models/DeliveryPlatformKind';\nimport { RawPushSubscription } from 'src/shared/models/RawPushSubscription';\nimport { SubscriptionStrategyKind } from 'src/shared/models/SubscriptionStrategyKind';\nimport type {\n  IMutableOSNotification,\n  IOSNotification,\n  NotificationClickEventInternal,\n  NotificationForegroundWillDisplayEventSerializable,\n} from 'src/shared/notifications/types';\nimport { SessionStatus } from 'src/shared/session/constants';\nimport {\n  type PageVisibilityRequest,\n  type PageVisibilityResponse,\n  type UpsertOrDeactivateSessionPayload,\n} from 'src/shared/session/types';\nimport { NotificationType } from 'src/shared/subscriptions/constants';\nimport type { NotificationTypeValue } from 'src/shared/subscriptions/types';\nimport { Browser } from 'src/shared/useragent/constants';\nimport { getBrowserName } from 'src/shared/useragent/detect';\nimport { VERSION } from 'src/shared/utils/EnvVariables';\nimport { cancelableTimeout } from '../helpers/CancelableTimeout';\nimport {\n  isValidPayload,\n  toNativeNotificationAction,\n  toOSNotification,\n} from '../helpers/notifications';\nimport { OSWebhookNotificationEventSender } from '../webhooks/notifications/OSWebhookNotificationEventSender';\nimport { getPushSubscriptionIdByToken } from './helpers';\nimport type {\n  OSMinifiedNotificationPayload,\n  OSServiceWorkerFields,\n  SubscriptionChangeEvent,\n} from './types';\n\ndeclare const self: ServiceWorkerGlobalScope & OSServiceWorkerFields;\n\nconst MAX_CONFIRMED_DELIVERY_DELAY = 25;\n\n/**\n * The main service worker script fetching and displaying notifications to users in the background even when the client\n * site is not running. The worker is registered via the navigator.serviceWorker.register() call after the user first\n * allows notification permissions, and is a pre-requisite to subscribing for push notifications.\n */\nexport class OneSignalServiceWorker {\n  static get _webhookNotificationEventSender() {\n    return new OSWebhookNotificationEventSender();\n  }\n\n  static async _getPushSubscriptionId(): Promise<string | undefined> {\n    const pushSubscription =\n      await self.registration.pushManager.getSubscription();\n    const pushToken = pushSubscription?.endpoint;\n    if (!pushToken) return undefined;\n    return getPushSubscriptionIdByToken(pushToken);\n  }\n\n  /**\n   * Allows message passing between this service worker and pages on the same domain.\n   * This allows events like notification dismissed, clicked, and displayed to be\n   * fired on the clients. It also allows the clients to communicate with the\n   * service worker to close all active notifications.\n   */\n  static get _workerMessenger(): WorkerMessengerSW {\n    if (!self._workerMessenger) {\n      self._workerMessenger = new WorkerMessengerSW(undefined);\n    }\n    return self._workerMessenger;\n  }\n\n  /**\n   * Service worker entry point.\n   */\n  static _run() {\n    self.addEventListener(\n      'activate',\n      OneSignalServiceWorker._onServiceWorkerActivated,\n    );\n    self.addEventListener('push', OneSignalServiceWorker._onPushReceived);\n    self.addEventListener('notificationclose', (event: NotificationEvent) =>\n      event.waitUntil(OneSignalServiceWorker._onNotificationClosed(event)),\n    );\n    self.addEventListener('notificationclick', (event: NotificationEvent) =>\n      event.waitUntil(OneSignalServiceWorker._onNotificationClicked(event)),\n    );\n    self.addEventListener('pushsubscriptionchange', (event: Event) => {\n      (event as FetchEvent).waitUntil(\n        OneSignalServiceWorker._onPushSubscriptionChange(\n          event as unknown as SubscriptionChangeEvent,\n        ),\n      );\n    });\n\n    self.addEventListener('message', (event: ExtendableMessageEvent) => {\n      const data: WorkerMessengerMessage = event.data;\n      const payload = data?.payload;\n\n      switch (data?.command) {\n        case WorkerMessengerCommand.SessionUpsert:\n          Log._debug('[Service Worker] Received SessionUpsert', payload);\n          OneSignalServiceWorker._debounceRefreshSession(\n            event,\n            payload as UpsertOrDeactivateSessionPayload,\n          );\n          break;\n        case WorkerMessengerCommand.SessionDeactivate:\n          Log._debug('[Service Worker] Received SessionDeactivate', payload);\n          OneSignalServiceWorker._debounceRefreshSession(\n            event,\n            payload as UpsertOrDeactivateSessionPayload,\n          );\n          break;\n        default:\n          return;\n      }\n    });\n    /*\n      According to\n      https://w3c.github.io/ServiceWorker/#run-service-worker-algorithm:\n\n      \"user agents are encouraged to show a warning that the event listeners\n      must be added on the very first evaluation of the worker script.\"\n\n      We have to register our event handler statically (not within an\n      asynchronous method) so that the browser can optimize not waking up the\n      service worker for events that aren't known for sure to be listened for.\n\n      Also see: https://github.com/w3c/ServiceWorker/issues/1156\n    */\n    Log._debug('Setting up message listeners.');\n\n    // delay for setting up test mocks like global.ServiceWorkerGlobalScope\n    setTimeout(() => {\n      // self.addEventListener('message') is statically added inside the listen() method\n      OneSignalServiceWorker._workerMessenger._listen();\n\n      // Install messaging event handlers for page <-> service worker communication\n      OneSignalServiceWorker._setupMessageListeners();\n    }, 0);\n  }\n\n  static async _getAppId(): Promise<string> {\n    if (self.location.search) {\n      const match = self.location.search.match(/appId=([0-9a-z-]+)&?/i);\n      // Successful regex matches are at position 1\n      if (match && match.length > 1) {\n        const appId = match[1];\n        return appId;\n      }\n    }\n    const { appId } = await getDBAppConfig();\n    return appId;\n  }\n\n  static _setupMessageListeners() {\n    OneSignalServiceWorker._workerMessenger._on(\n      WorkerMessengerCommand.WorkerVersion,\n      () => {\n        Log._debug('[Service Worker] Received worker version message.');\n        OneSignalServiceWorker._workerMessenger._broadcast(\n          WorkerMessengerCommand.WorkerVersion,\n          VERSION,\n        );\n      },\n    );\n    OneSignalServiceWorker._workerMessenger._on(\n      WorkerMessengerCommand.Subscribe,\n      async (appConfigBundle: AppConfig) => {\n        const appConfig = appConfigBundle;\n        Log._debug('[Service Worker] Received subscribe message.');\n        const context = new ContextSW(appConfig);\n        const rawSubscription = await context._subscriptionManager._subscribe(\n          SubscriptionStrategyKind.ResubscribeExisting,\n        );\n        const subscription =\n          await context._subscriptionManager._registerSubscription(\n            rawSubscription,\n          );\n        OneSignalServiceWorker._workerMessenger._broadcast(\n          WorkerMessengerCommand.Subscribe,\n          subscription._serialize(),\n        );\n      },\n    );\n    OneSignalServiceWorker._workerMessenger._on(\n      WorkerMessengerCommand.SubscribeNew,\n      async (appConfigBundle: AppConfig) => {\n        const appConfig = appConfigBundle;\n        Log._debug('[Service Worker] Received subscribe new message.');\n        const context = new ContextSW(appConfig);\n        const rawSubscription = await context._subscriptionManager._subscribe(\n          SubscriptionStrategyKind.SubscribeNew,\n        );\n        const subscription =\n          await context._subscriptionManager._registerSubscription(\n            rawSubscription,\n          );\n\n        OneSignalServiceWorker._workerMessenger._broadcast(\n          WorkerMessengerCommand.SubscribeNew,\n          subscription._serialize(),\n        );\n      },\n    );\n\n    OneSignalServiceWorker._workerMessenger._on(\n      WorkerMessengerCommand.AreYouVisibleResponse,\n      async (payload: PageVisibilityResponse) => {\n        Log._debug(\n          '[Service Worker] Received response for AreYouVisible',\n          payload,\n        );\n\n        const timestamp = payload.timestamp;\n        if (self.clientsStatus?.timestamp !== timestamp) {\n          return;\n        }\n\n        self.clientsStatus.receivedResponsesCount++;\n        if (payload.focused) {\n          self.clientsStatus.hasAnyActiveSessions = true;\n        }\n      },\n    );\n    OneSignalServiceWorker._workerMessenger._on(\n      WorkerMessengerCommand.SetLogging,\n      async (payload: { shouldLog: boolean }) => {\n        if (payload.shouldLog) {\n          self.shouldLog = true;\n        } else {\n          self.shouldLog = undefined;\n        }\n      },\n    );\n  }\n\n  /**\n   * Occurs when a push message is received.\n   * This method handles the receipt of a push signal on all web browsers except Safari, which uses the OS to handle\n   * notifications.\n   */\n  static _onPushReceived(event: PushEvent): void {\n    Log._debug(\n      `Called onPushReceived(${JSON.stringify(event, null, 4)}):`,\n      event,\n    );\n\n    event.waitUntil(\n      OneSignalServiceWorker._parseOrFetchNotifications(event)\n        .then(\n          async (rawNotificationsArray: OSMinifiedNotificationPayload[]) => {\n            //Display push notifications in the order we received them\n            const notificationEventPromiseFns = [];\n            const notificationReceivedPromises: Promise<void>[] = [];\n            const appId = await OneSignalServiceWorker._getAppId();\n\n            for (const rawNotification of rawNotificationsArray) {\n              Log._debug('Raw Notification from OneSignal:', rawNotification);\n              const notification = toOSNotification(rawNotification);\n\n              notificationReceivedPromises.push(\n                putNotificationReceivedForOutcomes(appId, notification),\n              );\n              // TODO: decide what to do with all the notif received promises\n              // Probably should have it's own error handling but not blocking the rest of the execution?\n\n              // Never nest the following line in a callback from the point of entering from retrieveNotifications\n              notificationEventPromiseFns.push(\n                (async (notif: IOSNotification) => {\n                  const event: NotificationForegroundWillDisplayEventSerializable =\n                    {\n                      notification: notif,\n                    };\n                  await OneSignalServiceWorker._workerMessenger\n                    ._broadcast(\n                      WorkerMessengerCommand.NotificationWillDisplay,\n                      event,\n                    )\n                    .catch((e) => Log._error(e));\n                  const pushSubscriptionId =\n                    await OneSignalServiceWorker._getPushSubscriptionId();\n\n                  OneSignalServiceWorker._webhookNotificationEventSender.willDisplay(\n                    notif,\n                    pushSubscriptionId,\n                  );\n\n                  return OneSignalServiceWorker._displayNotification(notif)\n                    .then(() =>\n                      OneSignalServiceWorker._sendConfirmedDelivery(notif),\n                    )\n                    .catch((e) => Log._error(e));\n                }).bind(null, notification),\n              );\n            }\n\n            // @ts-expect-error - TODO: improve type\n            return notificationEventPromiseFns.reduce((p, fn) => {\n              // @ts-expect-error - TODO: improve type\n              return (p = p.then(fn));\n            }, Promise.resolve());\n          },\n        )\n        .catch((e) => {\n          Log._debug('Failed to display a notification:', e);\n        }),\n    );\n  }\n\n  /**\n   * Makes a PUT call to log the delivery of the notification\n   * @param notification A JSON object containing notification details.\n   * @returns {Promise}\n   */\n  static async _sendConfirmedDelivery(\n    notification: IOSNotification,\n  ): Promise<void | null> {\n    if (!notification) return;\n\n    if (!OneSignalServiceWorker._browserSupportsConfirmedDelivery())\n      return null;\n\n    if (!notification.confirmDelivery) return;\n\n    const appId = await OneSignalServiceWorker._getAppId();\n    const pushSubscriptionId = await this._getPushSubscriptionId();\n\n    // app and notification ids are required, decided to exclude deviceId from required params\n    // In rare case we don't have it we can still report as confirmed to backend to increment count\n    const hasRequiredParams = !!(appId && notification.notificationId);\n    if (!hasRequiredParams) return;\n\n    // JSON.stringify() does not include undefined values\n    // Our response will not contain those fields here which have undefined values\n    const postData = {\n      player_id: pushSubscriptionId,\n      app_id: appId,\n      device_type: getDeviceType(),\n    };\n\n    Log._debug(\n      `Called sendConfirmedDelivery(${JSON.stringify(notification, null, 4)})`,\n    );\n\n    await delay(\n      Math.floor(Math.random() * MAX_CONFIRMED_DELIVERY_DELAY * 1_000),\n    );\n    await OneSignalApiBase.put(\n      `notifications/${notification.notificationId}/report_received`,\n      postData,\n    );\n  }\n\n  /**\n   * Confirmed Delivery isn't supported on Safari since they are very strict about the amount\n   * of time you have to finish the onpush event. Spending to much time in the onpush event\n   * will cause the push endpoint to become revoked!, causing the device to stop receiving pushes!\n   *\n   * iPadOS 16.4 it was observed to be only about 10 secounds.\n   * macOS 13.3 didn't seem to have this restriction when testing up to a 25 secound delay, however\n   * to be safe we are disabling it for all Safari browsers.\n   */\n  static _browserSupportsConfirmedDelivery(): boolean {\n    return getBrowserName() !== Browser.Safari;\n  }\n\n  /**\n   * Gets an array of window clients\n   * @returns {Promise}\n   */\n  static async _getWindowClients(): Promise<ReadonlyArray<WindowClient>> {\n    return await self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true,\n    });\n  }\n\n  static async _updateSessionBasedOnHasActive(\n    event: ExtendableMessageEvent,\n    hasAnyActiveSessions: boolean,\n    options: UpsertOrDeactivateSessionPayload,\n  ) {\n    if (hasAnyActiveSessions) {\n      await upsertSession(\n        options.appId,\n        options.onesignalId,\n        options.subscriptionId,\n        options.sessionThreshold,\n        options.enableSessionDuration,\n        options.sessionOrigin,\n        options.outcomesConfig,\n      );\n    } else {\n      const cancelableFinalize = await deactivateSession(\n        options.appId,\n        options.onesignalId,\n        options.subscriptionId,\n        options.sessionThreshold,\n        options.enableSessionDuration,\n        options.outcomesConfig,\n      );\n      if (cancelableFinalize) {\n        self.cancel = cancelableFinalize.cancel;\n        event.waitUntil(cancelableFinalize.promise);\n      }\n    }\n  }\n\n  static async _refreshSession(\n    event: ExtendableMessageEvent,\n    options: UpsertOrDeactivateSessionPayload,\n  ): Promise<void> {\n    Log._debug('[Service Worker] refreshSession');\n    /**\n     * getWindowClients -> check for the first focused\n     * unfortunately, not enough for safari, it always returns false for focused state of a client\n     * have to workaround it with messaging to the client.\n     */\n    const windowClients = await this._getWindowClients();\n\n    if (options.isSafari) {\n      await OneSignalServiceWorker._checkIfAnyClientsFocusedAndUpdateSession(\n        event,\n        windowClients,\n        options,\n      );\n    } else {\n      const hasAnyActiveSessions: boolean = windowClients.some(\n        (w) => (w as WindowClient).focused,\n      );\n      Log._debug('[Service Worker] hasAnyActiveSessions', hasAnyActiveSessions);\n      await OneSignalServiceWorker._updateSessionBasedOnHasActive(\n        event,\n        hasAnyActiveSessions,\n        options,\n      );\n    }\n  }\n\n  static async _checkIfAnyClientsFocusedAndUpdateSession(\n    event: ExtendableMessageEvent,\n    windowClients: ReadonlyArray<Client>,\n    sessionInfo: UpsertOrDeactivateSessionPayload,\n  ): Promise<void> {\n    const timestamp = new Date().getTime();\n    self.clientsStatus = {\n      timestamp,\n      sentRequestsCount: 0,\n      receivedResponsesCount: 0,\n      hasAnyActiveSessions: false,\n    };\n    const payload: PageVisibilityRequest = { timestamp };\n    windowClients.forEach((c) => {\n      // keeping track of number of sent requests mostly for debugging purposes\n      self.clientsStatus!.sentRequestsCount++;\n      c.postMessage({ command: WorkerMessengerCommand.AreYouVisible, payload });\n    });\n    const updateOnHasActive = async () => {\n      Log._debug('updateSessionBasedOnHasActive', self.clientsStatus);\n      await OneSignalServiceWorker._updateSessionBasedOnHasActive(\n        event,\n        self.clientsStatus!.hasAnyActiveSessions,\n        sessionInfo,\n      );\n      self.clientsStatus = undefined;\n    };\n    const getClientStatusesCancelable = cancelableTimeout(\n      updateOnHasActive,\n      0.5,\n    );\n    self.cancel = getClientStatusesCancelable.cancel;\n    event.waitUntil(getClientStatusesCancelable.promise);\n  }\n\n  static _debounceRefreshSession(\n    event: ExtendableMessageEvent,\n    options: UpsertOrDeactivateSessionPayload,\n  ) {\n    Log._debug('[Service Worker] debounceRefreshSession', options);\n\n    if (self.cancel) {\n      self.cancel();\n      self.cancel = undefined;\n    }\n\n    const executeRefreshSession = async () => {\n      await OneSignalServiceWorker._refreshSession(event, options);\n    };\n\n    const cancelableRefreshSession = cancelableTimeout(\n      executeRefreshSession,\n      1,\n    );\n    self.cancel = cancelableRefreshSession.cancel;\n    event.waitUntil(cancelableRefreshSession.promise);\n  }\n\n  /**\n   * Given an image URL, returns a proxied HTTPS image using the https://images.weserv.nl service.\n   * For a null image, returns null so that no icon is displayed.\n   * If the image protocol is HTTPS, or origin contains localhost or starts with 192.168.*.*, we do not proxy the image.\n   * @param imageUrl An HTTP or HTTPS image URL.\n   */\n  static _ensureImageResourceHttps(imageUrl?: string) {\n    if (imageUrl) {\n      try {\n        const parsedImageUrl = new URL(imageUrl);\n        if (\n          parsedImageUrl.hostname === 'localhost' ||\n          parsedImageUrl.hostname.indexOf('192.168') !== -1 ||\n          parsedImageUrl.hostname === '127.0.0.1' ||\n          parsedImageUrl.protocol === 'https:'\n        ) {\n          return imageUrl;\n        }\n        if (\n          parsedImageUrl.hostname === 'i0.wp.com' ||\n          parsedImageUrl.hostname === 'i1.wp.com' ||\n          parsedImageUrl.hostname === 'i2.wp.com' ||\n          parsedImageUrl.hostname === 'i3.wp.com'\n        ) {\n          /* Their site already uses Jetpack, just make sure Jetpack is HTTPS */\n          return `https://${parsedImageUrl.hostname}${parsedImageUrl.pathname}`;\n        }\n        /* HTTPS origin hosts can be used by prefixing the hostname with ssl: */\n        const replacedImageUrl = parsedImageUrl.host + parsedImageUrl.pathname;\n        return `https://i0.wp.com/${replacedImageUrl}`;\n      } catch (e) {\n        Log._error('ensureImageResourceHttps: ', e);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Given a structured notification object, HTTPS-ifies the notification icons and action button icons, if they exist.\n   */\n  static _ensureNotificationResourcesHttps(\n    notification: IMutableOSNotification,\n  ) {\n    if (notification) {\n      if (notification.icon) {\n        notification.icon = OneSignalServiceWorker._ensureImageResourceHttps(\n          notification.icon,\n        );\n      }\n      if (notification.image) {\n        notification.image = OneSignalServiceWorker._ensureImageResourceHttps(\n          notification.image,\n        );\n      }\n      if (notification.actionButtons && notification.actionButtons.length > 0) {\n        for (const button of notification.actionButtons) {\n          if (button.icon) {\n            button.icon = OneSignalServiceWorker._ensureImageResourceHttps(\n              button.icon,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Actually displays a visible notification to the user.\n   * Any event needing to display a notification calls this so that all the display options can be centralized here.\n   * @param notification A structured notification object.\n   */\n  static async _displayNotification(notification: IMutableOSNotification) {\n    Log._debug(\n      `Called displayNotification(${JSON.stringify(notification, null, 4)}):`,\n      notification,\n    );\n\n    // Use the default title if one isn't provided\n    const defaultTitle = await OneSignalServiceWorker._getTitle();\n    // Use the default icon if one isn't provided\n    const defaultIcon = await getOptionsValue<string>('defaultIcon');\n    // Get option of whether we should leave notification displaying indefinitely\n    const persistNotification = await getOptionsValue<boolean>(\n      'persistNotification',\n    );\n\n    // Get app ID for tag value\n    const appId = await OneSignalServiceWorker._getAppId();\n\n    notification.title = notification.title ? notification.title : defaultTitle;\n    notification.icon = notification.icon\n      ? notification.icon\n      : defaultIcon\n        ? defaultIcon\n        : undefined;\n\n    OneSignalServiceWorker._ensureNotificationResourcesHttps(notification);\n\n    const notificationOptions: NotificationOptions = {\n      body: notification.body,\n      icon: notification.icon,\n      /*\n       On Chrome 56, a large image can be displayed:\n       https://bugs.chromium.org/p/chromium/issues/detail?id=614456\n       */\n      // @ts-expect-error - image is not standard?\n      image: notification.image,\n      /*\n       On Chrome 44+, use this property to store extra information which\n       you can read back when the notification gets invoked from a\n       notification click or dismissed event. We serialize the\n       notification in the 'data' field and read it back in other events.\n       See:\n       https://developers.google.com/web/updates/2015/05/notifying-you-of-changes-to-notifications?hl=en\n       */\n      data: notification,\n      /*\n       On Chrome 48+, action buttons show below the message body of the\n       notification. Clicking either button takes the user to a link. See:\n       https://developers.google.com/web/updates/2016/01/notification-actions\n       */\n      actions: toNativeNotificationAction(notification.actionButtons),\n      /*\n       Tags are any string value that groups notifications together. Two\n       or notifications sharing a tag replace each other.\n       */\n      tag: notification.topic || appId,\n      /*\n       On Chrome 47+ (desktop), notifications will be dismissed after 20\n       seconds unless requireInteraction is set to true. See:\n       https://developers.google.com/web/updates/2015/10/notification-requireInteractiom\n       */\n      requireInteraction: persistNotification !== false,\n      /*\n       On Chrome 50+, by default notifications replacing\n       identically-tagged notifications no longer vibrate/signal the user\n       that a new notification has come in. This flag allows subsequent\n       notifications to re-alert the user. See:\n       https://developers.google.com/web/updates/2016/03/notifications\n       */\n      renotify: true,\n      /*\n       On Chrome 53+, returns the URL of the image used to represent the\n       notification when there is not enough space to display the\n       notification itself.\n\n       The URL of an image to represent the notification when there is not\n       enough space to display the notification itself such as, for\n       example, the Android Notification Bar. On Android devices, the\n       badge should accommodate devices up to 4x resolution, about 96 by\n       96 px, and the image will be automatically masked.\n       */\n      badge: notification.badgeIcon,\n    };\n\n    await self.registration.showNotification(\n      notification.title,\n      notificationOptions,\n    );\n\n    if (this._requiresMacOS15ChromiumAfterDisplayWorkaround()) {\n      await delay(1_000);\n    }\n  }\n\n  // Workaround: For Chromium browsers displaying an extra notification, even\n  // when background rules are followed.\n  // For reference, the notification body is \"This site has been updated in the background\".\n  // https://issues.chromium.org/issues/378103918\n  static _requiresMacOS15ChromiumAfterDisplayWorkaround(): boolean {\n    const userAgentData = (navigator as any).userAgentData;\n    const isMacOS = userAgentData?.platform === 'macOS';\n    const isChromium = !!userAgentData?.brands?.some(\n      (item: { brand: string }) => item.brand === 'Chromium',\n    );\n    return isMacOS && isChromium;\n  }\n\n  /**\n   * Returns false if the given URL matches a few special URLs designed to skip opening a URL when clicking a\n   * notification. Otherwise returns true and the link will be opened.\n   * @param url\n   */\n  static _shouldOpenNotificationUrl(url: string) {\n    return (\n      url !== 'javascript:void(0);' &&\n      url !== 'do_not_open' &&\n      !containsMatch(url, '_osp=do_not_open')\n    );\n  }\n\n  /**\n   * Occurs when a notification is dismissed by the user (clicking the 'X') or all notifications are cleared.\n   * Supported on: Chrome 50+ only\n   */\n  static async _onNotificationClosed(event: NotificationEvent) {\n    Log._debug(\n      `Called onNotificationClosed(${JSON.stringify(event, null, 4)}):`,\n      event,\n    );\n    const notification = event.notification.data as IOSNotification;\n\n    OneSignalServiceWorker._workerMessenger\n      ._broadcast(WorkerMessengerCommand.NotificationDismissed, notification)\n      .catch((e) => Log._error(e));\n    const pushSubscriptionId =\n      await OneSignalServiceWorker._getPushSubscriptionId();\n\n    OneSignalServiceWorker._webhookNotificationEventSender.dismiss(\n      notification,\n      pushSubscriptionId,\n    );\n  }\n\n  /**\n   * After clicking a notification, determines the URL to open based on whether an action button was clicked or the\n   * notification body was clicked.\n   */\n  static async _getNotificationUrlToOpen(\n    notification: IOSNotification,\n    actionId?: string,\n  ): Promise<string> {\n    // If the user clicked an action button, use the URL provided by the action button.\n    // Unless the action button URL is null\n    if (actionId) {\n      const clickedButton = notification?.actionButtons?.find(\n        (button) => button.actionId === actionId,\n      );\n      if (clickedButton?.launchURL && clickedButton.launchURL !== '') {\n        return clickedButton.launchURL;\n      }\n    }\n\n    if (notification.launchURL && notification.launchURL !== '') {\n      return notification.launchURL;\n    }\n\n    const { defaultNotificationUrl: dbDefaultNotificationUrl } =\n      await getAppState();\n    if (dbDefaultNotificationUrl) {\n      return dbDefaultNotificationUrl;\n    }\n\n    return location.origin;\n  }\n\n  /**\n   * Occurs when the notification's body or action buttons are clicked. Does not occur if the notification is\n   * dismissed by clicking the 'X' icon. See the notification close event for the dismissal event.\n   */\n  static async _onNotificationClicked(event: NotificationEvent) {\n    Log._debug(\n      `Called onNotificationClicked(${JSON.stringify(event, null, 4)}):`,\n      event,\n    );\n\n    // Close the notification first here, before we do anything that might fail\n    event.notification.close();\n\n    const osNotification = event.notification.data as IOSNotification;\n\n    let notificationClickHandlerMatch = 'exact';\n    let notificationClickHandlerAction = 'navigate';\n\n    const matchPreference = await getOptionsValue<string>(\n      'notificationClickHandlerMatch',\n    );\n    if (matchPreference) notificationClickHandlerMatch = matchPreference;\n\n    const actionPreference = await getOptionsValue<string>(\n      'notificationClickHandlerAction',\n    );\n    if (actionPreference) notificationClickHandlerAction = actionPreference;\n\n    const launchUrl = await OneSignalServiceWorker._getNotificationUrlToOpen(\n      osNotification,\n      event.action,\n    );\n    const notificationOpensLink: boolean =\n      OneSignalServiceWorker._shouldOpenNotificationUrl(launchUrl);\n    const appId = await OneSignalServiceWorker._getAppId();\n    const deviceType = getDeviceType();\n\n    const notificationClickEvent: NotificationClickEventInternal = {\n      notification: osNotification,\n      result: {\n        actionId: event.action,\n        url: launchUrl,\n      },\n      timestamp: new Date().getTime(),\n    };\n\n    Log._info('NotificationClicked', notificationClickEvent);\n    const saveNotificationClickedPromise = (async (notificationClickEvent) => {\n      try {\n        const existingSession = await getCurrentSession();\n        if (\n          existingSession &&\n          existingSession.status === SessionStatus.Active\n        ) {\n          return;\n        }\n\n        await putNotificationClickedForOutcomes(appId, notificationClickEvent);\n\n        // upgrade existing session to be directly attributed to the notif\n        // if it results in re-focusing the site\n        if (existingSession) {\n          existingSession.notificationId =\n            notificationClickEvent.notification.notificationId;\n          await db.put('Sessions', existingSession);\n        }\n      } catch (e) {\n        Log._error('Failed to save clicked notification.', e);\n      }\n    })(notificationClickEvent);\n\n    // Start making REST API requests BEFORE self.clients.openWindow is called.\n    // It will cause the service worker to stop on Chrome for Android when site is added to the home screen.\n    const pushSubscriptionId = await this._getPushSubscriptionId();\n    const convertedAPIRequests =\n      OneSignalServiceWorker._sendConvertedAPIRequests(\n        appId,\n        pushSubscriptionId,\n        notificationClickEvent,\n        deviceType,\n      );\n\n    /*\n     Check if we can focus on an existing tab instead of opening a new url.\n     If an existing tab with exactly the same URL already exists, then this existing tab is focused instead of\n     an identical new tab being created. With a special setting, any existing tab matching the origin will\n     be focused instead of an identical new tab being created.\n     */\n    const activeClients = await OneSignalServiceWorker._getWindowClients();\n    let doNotOpenLink = false;\n    for (const client of activeClients) {\n      const clientUrl = client.url;\n      let clientOrigin = '';\n      try {\n        clientOrigin = new URL(clientUrl).origin;\n      } catch (e) {\n        Log._error(`Failed to get the HTTP site's actual origin:`, e);\n      }\n      let launchOrigin = null;\n      try {\n        // Check if the launchUrl is valid; it can be null\n        launchOrigin = new URL(launchUrl).origin;\n      } catch (e) {\n        Log._error(`Failed parse launchUrl:`, e);\n      }\n\n      if (\n        (notificationClickHandlerMatch === 'exact' &&\n          clientUrl === launchUrl) ||\n        (notificationClickHandlerMatch === 'origin' &&\n          clientOrigin === launchOrigin)\n      ) {\n        if (\n          client.url === launchUrl ||\n          (notificationClickHandlerAction === 'focus' &&\n            clientOrigin === launchOrigin)\n        ) {\n          OneSignalServiceWorker._workerMessenger._unicast(\n            WorkerMessengerCommand.NotificationClicked,\n            notificationClickEvent,\n            client,\n          );\n          try {\n            if (client instanceof WindowClient) await client.focus();\n          } catch (e) {\n            Log._error('Failed to focus:', client, e);\n          }\n        } else {\n          /*\n          We must focus first; once the client navigates away, it may not be on a domain the same domain, and\n          the client ID may change, making it unable to focus.\n\n          client.navigate() is available on Chrome 49+ and Firefox 50+.\n           */\n          if (client instanceof WindowClient && client.navigate) {\n            try {\n              Log._debug(\n                'Client is standard HTTPS site. Attempting to focus() client.',\n              );\n              if (client instanceof WindowClient) await client.focus();\n            } catch (e) {\n              Log._error('Failed to focus:', client, e);\n            }\n            try {\n              if (notificationOpensLink) {\n                Log._debug(`Redirecting HTTPS site to (${launchUrl}).`);\n                await client.navigate(launchUrl);\n              } else {\n                Log._debug('Not navigating because link is special.');\n              }\n            } catch (e) {\n              Log._error('Failed to navigate:', client, launchUrl, e);\n            }\n          } else {\n            // If client.navigate() isn't available, we have no other option but to open a new tab to the URL.\n            await OneSignalServiceWorker._openUrl(launchUrl);\n          }\n        }\n        doNotOpenLink = true;\n        break;\n      }\n    }\n\n    if (notificationOpensLink && !doNotOpenLink) {\n      await OneSignalServiceWorker._openUrl(launchUrl);\n    }\n    if (saveNotificationClickedPromise) {\n      await saveNotificationClickedPromise;\n    }\n\n    return await convertedAPIRequests;\n  }\n\n  /**\n   * Makes network calls for the notification open event to;\n   *    1. OneSignal.com to increase the notification open count.\n   *    2. A website developer defined webhook URL, if set.\n   */\n  static async _sendConvertedAPIRequests(\n    appId: string | undefined | null,\n    pushSubscriptionId: string | undefined,\n    notificationClickEvent: NotificationClickEventInternal,\n    deviceType: DeliveryPlatformKindValue,\n  ): Promise<void> {\n    const notificationData = notificationClickEvent.notification;\n\n    if (!notificationData.notificationId) {\n      console.error(\n        'No notification id, skipping networks calls to report open!',\n      );\n      return;\n    }\n\n    let onesignalRestPromise: Promise<any> | undefined;\n\n    if (appId) {\n      onesignalRestPromise = OneSignalApiBase.put(\n        `notifications/${notificationData.notificationId}`,\n        {\n          app_id: appId,\n          player_id: pushSubscriptionId,\n          opened: true,\n          device_type: deviceType,\n        },\n      );\n    } else {\n      console.error(\n        'No app Id, skipping OneSignal API call for notification open!',\n      );\n    }\n\n    await OneSignalServiceWorker._webhookNotificationEventSender.click(\n      notificationClickEvent,\n      pushSubscriptionId,\n    );\n    if (onesignalRestPromise) await onesignalRestPromise;\n  }\n\n  /**\n   * Attempts to open the given url in a new browser tab. Called when a notification is clicked.\n   * @param url May not be well-formed.\n   */\n  static async _openUrl(url: string): Promise<Client | null> {\n    Log._debug('Opening notification URL:', url);\n    try {\n      return await self.clients.openWindow(url);\n    } catch (e) {\n      Log._warn(`Failed to open the URL '${url}':`, e);\n      return null;\n    }\n  }\n\n  /**\n   * Fires when the ServiceWorker can control pages.\n   * @param event\n   */\n  static _onServiceWorkerActivated(event: ExtendableEvent) {\n    Log._info(`OneSignal Service Worker activated (version ${VERSION})`);\n    event.waitUntil(self.clients.claim());\n  }\n\n  static async _onPushSubscriptionChange(event: SubscriptionChangeEvent) {\n    Log._debug(\n      `Called onPushSubscriptionChange(${JSON.stringify(event, null, 4)}):`,\n      event,\n    );\n\n    const appId = await OneSignalServiceWorker._getAppId();\n    if (!appId) {\n      // Without an app ID, we can't make any calls\n      return;\n    }\n    const appConfig = await getServerAppConfig(\n      { appId },\n      downloadSWServerAppConfig,\n    );\n    if (!appConfig) {\n      // Without a valid app config (e.g. deleted app), we can't make any calls\n      return;\n    }\n    const context = new ContextSW(appConfig);\n\n    // Get our current device ID\n    let deviceIdExists: boolean;\n    {\n      let deviceId: string | null | undefined = (await getSubscription())\n        .deviceId;\n\n      deviceIdExists = !!deviceId;\n      if (!deviceIdExists && event.oldSubscription) {\n        // We don't have the device ID stored, but we can look it up from our old subscription\n        deviceId = await getUserIdFromSubscriptionIdentifier(\n          appId,\n          getDeviceType(),\n          event.oldSubscription.endpoint,\n        );\n\n        // Store the device ID, so it can be looked up when subscribing\n        const subscription = await getSubscription();\n        subscription.deviceId = deviceId;\n        await setSubscription(subscription);\n      }\n      deviceIdExists = !!deviceId;\n    }\n\n    // Get our new push subscription\n    let rawPushSubscription: RawPushSubscription | undefined;\n\n    // Set it initially by the provided new push subscription\n    const providedNewSubscription = event.newSubscription;\n    if (providedNewSubscription) {\n      rawPushSubscription = RawPushSubscription._setFromW3cSubscription(\n        providedNewSubscription,\n      );\n    } else {\n      // Otherwise set our push registration by resubscribing\n      try {\n        rawPushSubscription = await context._subscriptionManager._subscribe(\n          SubscriptionStrategyKind.SubscribeNew,\n        );\n      } catch (e) {\n        // Let rawPushSubscription be null\n      }\n    }\n    const hasNewSubscription = !!rawPushSubscription;\n\n    if (!deviceIdExists && !hasNewSubscription) {\n      await db.delete('Ids', 'userId');\n      await db.delete('Ids', 'registrationId');\n    } else {\n      /*\n        Determine subscription state we should set new record to.\n\n        If the permission is revoked, we should set the subscription state to permission revoked.\n       */\n      let subscriptionState: null | NotificationTypeValue = null;\n      const pushPermission = Notification.permission;\n\n      if (pushPermission !== 'granted') {\n        subscriptionState = NotificationType.PermissionRevoked;\n      } else if (!rawPushSubscription) {\n        /*\n          If it's not a permission revoked issue, the subscription expired or was revoked by the\n          push server.\n         */\n        subscriptionState = NotificationType.PushSubscriptionRevoked;\n      }\n\n      // rawPushSubscription may be null if no push subscription was retrieved\n      await context._subscriptionManager._registerSubscription(\n        rawPushSubscription,\n        subscriptionState,\n      );\n    }\n  }\n\n  /**\n   * Returns a promise that is fulfilled with either the default title from the database (first priority) or the page title from the database (alternate result).\n   */\n  static _getTitle(): Promise<string> {\n    return new Promise((resolve) => {\n      Promise.all([\n        getOptionsValue<string>('defaultTitle'),\n        getOptionsValue<string>('pageTitle'),\n      ]).then(([defaultTitle, pageTitle]) => {\n        if (defaultTitle !== null) {\n          resolve(defaultTitle);\n        } else if (pageTitle != null) {\n          resolve(pageTitle);\n        } else {\n          resolve('');\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns an array of raw notification objects, read from the event.data.payload property\n   * @param event\n   * @returns An array of notifications. The new web push protocol will only ever contain one notification, however\n   * an array is returned for backwards compatibility with the rest of the service worker plumbing.\n   */\n  static _parseOrFetchNotifications(\n    event: PushEvent,\n  ): Promise<OSMinifiedNotificationPayload[]> {\n    if (!event || !event.data) {\n      return Promise.reject('Missing event.data on push payload!');\n    }\n\n    const isValidPayload = OneSignalServiceWorker._isValidPushPayload(\n      event.data,\n    );\n    if (isValidPayload) {\n      Log._debug('Received a valid encrypted push payload.');\n      const payload: OSMinifiedNotificationPayload = event.data.json();\n      return Promise.resolve([payload]);\n    }\n\n    /*\n     We received a push message payload from another service provider or a malformed\n     payload. The last received notification will be displayed.\n    */\n    return Promise.reject(\n      `Unexpected push message payload received: ${event.data}`,\n    );\n  }\n\n  /**\n   * Returns true if the raw data payload is a OneSignal push message in the format of the new web push protocol.\n   * Otherwise returns false.\n   * @param rawData The raw PushMessageData from the push event's event.data, not already parsed to JSON.\n   */\n  static _isValidPushPayload(rawData: PushMessageData) {\n    try {\n      const payload = rawData.json();\n      if (isValidPayload(payload)) {\n        return true;\n      } else {\n        Log._debug(\n          'isValidPushPayload: Valid JSON but missing notification UUID:',\n          payload,\n        );\n        return false;\n      }\n    } catch (e) {\n      Log._debug('isValidPushPayload: Parsing to JSON failed with:', e);\n      return false;\n    }\n  }\n}\n\nOneSignalServiceWorker._run();\n","import { db } from 'src/shared/database/client';\n\n/**\n * WARNING: This is a temp workaround for the ServiceWorker context only!\n * PURPOSE: CoreModuleDirector doesn't work in the SW context.\n * TODO: This is duplicated logic tech debt to address later\n */\nexport async function getPushSubscriptionIdByToken(\n  token: string,\n): Promise<string | undefined> {\n  const pushSubscriptions = await db.getAll('subscriptions');\n  for (const pushSubscription of pushSubscriptions) {\n    if (pushSubscription['token'] === token) {\n      return pushSubscription['id'] as string;\n    }\n  }\n  return undefined;\n}\n","import { getConsentRequired } from '../helpers/localStorage';\nimport Log from '../libraries/Log';\nimport { db, getIdsValue, getOptionsValue } from './client';\nimport type { AppState } from './types';\n\nexport const getDBAppConfig = async () => {\n  const config: any = {};\n  const appIdStr = await getIdsValue<string>('appId');\n  config.appId = appIdStr;\n  config.vapidPublicKey = await getOptionsValue<string>('vapidPublicKey');\n  return config;\n};\n\nexport const getAppState = async (): Promise<AppState> => {\n  const defaultNotificationUrl = await getOptionsValue<string>('defaultUrl');\n  const defaultNotificationTitle =\n    await getOptionsValue<string>('defaultTitle');\n  const lastKnownPushEnabled = await getOptionsValue<boolean>('isPushEnabled');\n  const lastKnownOptedIn = await getOptionsValue<boolean>('lastOptedIn');\n\n  // lastKnown<PushId|PushToken|OptedIn> are used to track changes to the user's subscription\n  // state. Displayed in the `current` & `previous` fields of the `subscriptionChange` event.\n  // want undefined instead of null since its used to check for subscription changes\n  const lastKnownPushId =\n    (await getOptionsValue<string>('lastPushId')) ?? undefined;\n  const lastKnownPushToken =\n    (await getOptionsValue<string>('lastPushToken')) ?? undefined;\n  return {\n    defaultNotificationUrl,\n    defaultNotificationTitle,\n    lastKnownPushEnabled,\n    lastKnownPushId,\n    lastKnownPushToken,\n    lastKnownOptedIn,\n  };\n};\n\nexport const setAppState = async (appState: AppState) => {\n  if (appState.defaultNotificationUrl)\n    await db.put('Options', {\n      key: 'defaultUrl',\n      value: appState.defaultNotificationUrl,\n    });\n  if (\n    appState.defaultNotificationTitle ||\n    appState.defaultNotificationTitle === ''\n  )\n    await db.put('Options', {\n      key: 'defaultTitle',\n      value: appState.defaultNotificationTitle,\n    });\n\n  if (appState.lastKnownPushEnabled != null)\n    await db.put('Options', {\n      key: 'isPushEnabled',\n      value: appState.lastKnownPushEnabled,\n    });\n\n  if (appState.lastKnownPushId != null)\n    await db.put('Options', {\n      key: 'lastPushId',\n      value: appState.lastKnownPushId,\n    });\n\n  if (appState.lastKnownPushToken != null)\n    await db.put('Options', {\n      key: 'lastPushToken',\n      value: appState.lastKnownPushToken,\n    });\n\n  if (appState.lastKnownOptedIn != null)\n    await db.put('Options', {\n      key: 'lastOptedIn',\n      value: appState.lastKnownOptedIn,\n    });\n};\n\n// make sure to also set OneSignal._consentGiven when updating 'userConsent'\nexport const getConsentGiven = async () => {\n  return (await getOptionsValue<boolean>('userConsent')) ?? false;\n};\n\nexport const isConsentRequiredButNotGiven = () => {\n  const consentRequired = getConsentRequired();\n  const consentGiven = OneSignal._consentGiven;\n\n  const requiredButNotGiven = consentRequired && !consentGiven;\n  if (requiredButNotGiven) Log._warn('Consent required but not given');\n\n  return requiredButNotGiven;\n};\n","/**\n * New clients will only be including this entry file, which will result in a reduced service worker size.\n */\nimport { OneSignalServiceWorker } from '../sw/serviceWorker/ServiceWorker';\n\n// Expose this class to the global scope\ndeclare const self: ServiceWorkerGlobalScope;\nself.OneSignalWorker = OneSignalServiceWorker;\n"],"names":["SubscriptionType","Browser","BROWSER_CONFIGS","_name","_pattern","_versionPattern","BROWSER_MAP","Chrome","Chromium","Firefox","Safari","getBrowserName","userAgent","config","test","version","match","name","getBrowser","navigator","VERSION","useSafariLegacyPush","window","safari","pushNotification","supportsVapidPush","PushSubscriptionOptions","prototype","hasOwnProperty","getSubscriptionType","getDeviceType","AppIDMissingError","Error","RetryLimitError","PermissionBlockedError","InvalidAppIdError","delay","ms","Promise","resolve","setTimeout","getValueOrDefault","value","defaultValue","isValidUuid","uuid","Log","_shouldLog","self","shouldLog","_setLevel","level","_createLogMethod","consoleMethod","args","this","console","static","post","action","data","headers","call","put","method","body","url","startsWith","split","reject","callHeaders","Headers","append","location","origin","key","Object","keys","contents","cache","JSON","stringify","executeFetch","legacy","URL","getOneSignalApiUrl","toString","async","retry","response","fetch","status","json","retryAfter","get","ok","result","retryAfterSeconds","parseInt","e","_error","IdentityConstants","encodeRFC3986URIComponent","str","encodeURIComponent","replace","c","charCodeAt","toUpperCase","updateUserByAlias","requestMetadata","alias","payload","appId","subscriptionId","subscriptionHeader","jwtHeader","OneSignalApiBase.patch","label","id","enforceAppId","downloadSWServerAppConfig","DEFAULT_SERVICE_WORKER_OPTIONS","scope","DelayedPromptType","SERVER_CONFIG_DEFAULTS_PROMPT_DELAYS","pageViews","timeDelay","SERVER_CONFIG_DEFAULTS_SLIDEDOWN","CONFIG_DEFAULTS_SLIDEDOWN_OPTIONS","type","text","actionMessage","acceptButton","cancelButton","autoPrompt","ConfigIntegrationKind","getPromptOptionsForDashboardConfiguration","serverConfig","staticPrompts","native","enabled","prompts","slidedown","isSlidedownAutoPromptConfigured","fullscreen","title","message","caption","autoAcceptTitle","customlink","getCustomLinkConfig","i","length","initialState","style","size","unsubscribeEnabled","explanation","subscribe","unsubscribe","color","button","getIntegrationCapabilities","integration","configuration","injectDefaultsIntoPromptOptions","promptOptions","defaultsFromServer","wholeUserConfig","customlinkUser","customlinkDefaults","promptOptionsConfig","map","promptOption","positiveUpdateButton","negativeUpdateButton","updateMessage","confirmMessage","categories","structuredClone","slice","hasAutoPromptProperty","autoRegister","getServerAppConfig","userConfig","downloadConfig","slidedownConfig","some","acceptButtonText","cancelButtonText","convertConfigToVersionOne","isSlidedownConfigVersion1","isCategory","options","tags","promptType","convertConfigToVersionTwo","upgradeConfigToVersionTwo","appConfig","configIntegrationKind","kind","getConfigIntegrationKind","hasUnsupportedSubdomain","siteInfo","proxyOriginEnabled","subdomainName","hasUnsupportedSubdomainForConfigIntegrationKind","mergedUserConfig","path","serviceWorkerPath","serviceWorkerParam","serviceWorker","useUserOverride","serviceWorkerOverrideForTypical","registrationScope","workerName","getServiceWorkerValues","app_id","autoResubscribe","proxyOrigin","welcomeNotification","disable","enable","notifyButton","bell","displayPredicate","position","showCredit","offset","bottom","left","right","colors","main","accent","tooltip","unsubscribed","subscribed","blocked","subscribing","unsubscribing","dialog","subscribeButton","unsubscribeButton","persistNotification","notificationBehavior","display","persist","webhooks","cors","corsEnable","notificationDisplayedHook","notificationClickedHook","notificationDismissedHook","notificationClickHandlerMatch","click","notificationClickHandlerAction","outcomes","direct","indirect","influencedTimePeriodMin","notification_attribution","minutes_since_displayed","influencedNotificationsLimit","limit","unattributed","getUserConfigForConfigIntegrationKind","siteName","restrictedOriginEnabled","features","restrict_origin","safariWebId","safari_web_id","vapidPublicKey","vapid_public_key","onesignalVapidPublicKey","onesignal_vapid_public_key","enableOnSession","enable_on_session","sessionThreshold","session_threshold","enableSessionDuration","web_on_focus_enabled","getMergedConfig","isHttp","isSecureContext","checkUnsupportedSubdomain","code","instanceOfAny","object","constructors","idbProxyableTypes","cursorAdvanceMethods","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","set","has","replaceTraps","callback","transformCachableValue","func","IDBCursor","advance","continue","continuePrimaryKey","includes","apply","unwrap","request","tx","done","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBDatabase","IDBObjectStore","IDBIndex","Proxy","IDBRequest","promise","success","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","storeName","transaction","store","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","Symbol","asyncIterator","ONESIGNAL_SESSION_KEY","SessionStatus","terminated","open","upgrade","blocking","indexedDB","openPromise","event","oldVersion","newVersion","then","db","catch","openDB","_db","newDbVersion","createObjectStore","keyPath","oldTableName","newTableName","oldValue","notificationId","notification","timestamp","deleteObjectStore","migrateOutcomesNotificationClickedTableForV5","migrateOutcomesNotificationReceivedTableForV5","currentExternalId","identityData","getAll","externalId","legacyModelName","modelName","migrateModelNameSubscriptionsTableForV6","_debug","getDb","dbPromise","clearStore","clear","getOptionsValue","getCurrentSession","cleanupCurrentSession","putNotificationReceivedForOutcomes","timeStamp","notificationReceivedForOutcomesToDatabase","Date","now","getAllNotificationClickedForOutcomes","notificationClickedForOutcomesFromDatabase","record","Subscription","deviceId","subscriptionToken","optedOut","createdAt","expirationTime","_serialize","_deserialize","bundle","subscription","getSubscription","dbOptedOut","dbNotOptedOut","setSubscription","cancelableTimeout","delayInSeconds","delayInMilliseconds","timerId","clearTimeoutHandle","startedExecution","clearTimeout","cancel","initializeNewSession","currentTimestamp","getTime","accumulatedDuration","lastActivatedTimestamp","lastDeactivatedTimestamp","sessionKey","startTimestamp","sendOnSessionCallIfNotPlayerCreate","onesignalId","sessionOrigin","session","resetSentUniqueOutcomes","aliasPair","updateUserPayload","refresh_device_metadata","deltas","session_count","enforceAlias","updateUserSession","finalizeSession","sendOnFocusEnabled","outcomesConfig","attribution","clickedNotifications","notificationIds","timeframeMs","maxTimestamp","allReceivedNotification","notificationReceivedForOutcomesFromDatabase","getAllNotificationReceivedForOutcomes","max","allReceivedNotificationSorted","arrayToSort","predicateForProperty","descending","doItInPlace","internalArrayToSort","sort","a","b","propertyA","propertyB","sortArrayOfObjects","notif","matchingNotificationIds","filter","notificationIdsToDelete","indexOf","forEach","getConfigAttribution","sessionDuration","session_time","outcomePayload","notification_ids","onesignal_id","_info","OneSignalApiBase.post","sendOutcome","sendSessionDuration","promises","o","sentDuringSession","timeInSecondsBetweenTimestamps","timestamp1","timestamp2","Math","floor","WorkerMessengerCommand","WorkerMessengerReplyBuffer","_replies","constructor","_addListener","command","onceListenerOnly","replies","push","_findListenersForMessage","_deleteListenerRecords","_deleteAllListenerRecords","_deleteListenerRecord","targetRecord","listenersForCommand","listenerRecordIndex","splice","WorkerMessengerBase","_context","context","_on","_once","_off","WorkerMessengerSW","_listen","_onWorkerMessageReceivedFromPage","bind","listenerRecords","listenersToRemove","listenersToCall","listenerRecord","_broadcast","clients","matchAll","includeUncontrolled","client","postMessage","_unicast","windowClient","RawPushSubscription","w3cEndpoint","w3cP256dh","w3cAuth","safariDeviceToken","_setFromW3cSubscription","pushSubscription","rawPushSubscription","endpoint","getKey","p256dh","auth","p256dh_base64encoded","btoa","String","fromCharCode","Uint8Array","auth_base64encoded","_setFromSafariSubscription","SubscriptionManagerBase","_config","_registerSubscription","_subscriptionState","_isAlreadyRegisteredWithOneSignal","OneSignal","_sessionInitAlreadyRunning","_subscribeWithVapidKey","pushManager","subscriptionStrategy","existingPushSubscription","_doPushUnsubscribe","newPushSubscription","isNewSubscription","_doPushSubscribe","_getVapidKeyForBrowser","_updateSubscriptionTime","base64String","base64","repeat","rawData","atob","outputArray","base64ToUint8Array","buffer","updateCreatedAt","applicationServerKey","subscriptionOptions","userVisibleOnly","existingSubscription","_warn","SubscriptionManagerSW","_subscribe","_subscribeFcmFromWorker","swRegistration","registration","active","pushPermission","permissionState","ContextSW","_appConfig","_subscriptionManager","_workerMessenger","toOSNotification","custom","alert","additionalData","launchURL","u","confirmDelivery","rr","icon","image","actionButtons","payloadButtons","actionId","n","p","topic","tag","badgeIcon","badge","OSWebhookSender","send","webhookTargetUrl","isServerCorsEnabled","fetchOptions","mode","OSWebhookNotificationEventSender","sender","heading","content","willDisplay","dismiss","OneSignalServiceWorker","_webhookNotificationEventSender","_getPushSubscriptionId","pushToken","token","pushSubscriptions","getPushSubscriptionIdByToken","_run","_onServiceWorkerActivated","_onPushReceived","waitUntil","_onNotificationClosed","_onNotificationClicked","_onPushSubscriptionChange","_debounceRefreshSession","_setupMessageListeners","_getAppId","search","appIdStr","getIdsValue","getDBAppConfig","appConfigBundle","rawSubscription","clientsStatus","receivedResponsesCount","focused","hasAnyActiveSessions","_parseOrFetchNotifications","rawNotificationsArray","notificationEventPromiseFns","notificationReceivedPromises","rawNotification","pushSubscriptionId","_displayNotification","_sendConfirmedDelivery","reduce","fn","_browserSupportsConfirmedDelivery","postData","player_id","device_type","random","OneSignalApiBase.put","_getWindowClients","_updateSessionBasedOnHasActive","sessionThresholdInSeconds","existingSession","clickedNotification","allClickedNotifications","find","getLastNotificationClickedForOutcomes","upsertSession","cancelableFinalize","thresholdInSeconds","finalizeSWSession","timeSinceLastActivatedInSeconds","deactivateSession","_refreshSession","windowClients","isSafari","_checkIfAnyClientsFocusedAndUpdateSession","w","sessionInfo","sentRequestsCount","getClientStatusesCancelable","cancelableRefreshSession","_ensureImageResourceHttps","imageUrl","parsedImageUrl","hostname","protocol","pathname","host","_ensureNotificationResourcesHttps","defaultTitle","_getTitle","defaultIcon","notificationOptions","actions","actionPayload","requireInteraction","renotify","showNotification","_requiresMacOS15ChromiumAfterDisplayWorkaround","userAgentData","isMacOS","platform","isChromium","brands","item","brand","_shouldOpenNotificationUrl","indexOfAble","_getNotificationUrlToOpen","clickedButton","defaultNotificationUrl","dbDefaultNotificationUrl","defaultNotificationTitle","lastKnownPushEnabled","lastKnownOptedIn","lastKnownPushId","lastKnownPushToken","getAppState","close","osNotification","matchPreference","actionPreference","launchUrl","notificationOpensLink","deviceType","notificationClickEvent","saveNotificationClickedPromise","notificationClickedForOutcomesToDatabase","putNotificationClickedForOutcomes","convertedAPIRequests","_sendConvertedAPIRequests","activeClients","doNotOpenLink","clientUrl","clientOrigin","launchOrigin","WindowClient","focus","navigate","_openUrl","notificationData","onesignalRestPromise","opened","openWindow","claim","deviceIdExists","oldSubscription","identifier","notification_types","getUserIdFromSubscriptionIdentifier","providedNewSubscription","newSubscription","subscriptionState","Notification","permission","pageTitle","_isValidPushPayload","isValidPayload","OneSignalWorker"],"mappings":"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","x_google_ignoreList":[25]}